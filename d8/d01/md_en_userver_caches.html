<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: Basics of Caches</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basics of Caches </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A cache in userver is a <a class="el" href="../../d3/df4/md_en_userver_component-system.html">component</a> that periodically polls an external resource and caches its response. Strictly speaking, the cache component is a shadow replica of some resource (database tables, mongo collections, etc.). The use of the cache is that the user receives the current data snapshot and works with that snapshot without waiting for updates. Cache updates occur asynchronously in the background and do not block users from working with the cache.</p>
<p>As a result, the user usually works with slightly outdated data, but at the same time always has an instant access to some version of the data.</p>
<p>Caches usually inherit from <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> or <a class="el" href="../../d9/d97/classcache_1_1LruCacheComponent.html" title="Base class for LRU-cache components.">cache::LruCacheComponent</a>. Sections below describe the features of <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a>. For information on <a class="el" href="../../d9/d97/classcache_1_1LruCacheComponent.html" title="Base class for LRU-cache components.">cache::LruCacheComponent</a> refer to <a class="el" href="../../d1/da0/md_en_userver_lru-cache.html">Least Recently Used (LRU) Caches and expirable LRU caches</a>.</p>
<h1><a class="anchor" id="autotoc_md68"></a>
Update Modes</h1>
<p>Caches have two update modes:</p><ul>
<li>Full update. In this mode, the cache requests its full state from an external resource.</li>
<li>Incremental update. In this mode, the cache requests changes since the last Full update, patching its current state.</li>
</ul>
<p>If there has not been a successful full update for a long time (more than the value of <code>full-update-interval</code>), then the next update will be full. In particular, if there is a full update error, the next update will also be full.</p>
<p>The cache can disable incremental updates and work only in full updates mode, or vice versa - work only in incremental updates mode. The very first update is always full, regardless of the settings.</p>
<p>Here's a sample update mode settings of <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> based cache: </p><div class="fragment"><div class="line">yaml</div>
<div class="line">  mongo-taxi-config-cache:</div>
<div class="line">    update-interval: 5s</div>
<div class="line">    update-jitter: 1s</div>
<div class="line">    full-update-interval: 10s</div>
<div class="line">    update-types: full-and-incremental</div>
</div><!-- fragment --><p>To disable incremental/full updates, specify this in the <code>update-types</code> tag, for example: </p><div class="fragment"><div class="line">yaml</div>
<div class="line">  js-pipeline-compilation:</div>
<div class="line">    # Can be only-full, only-incremental, full-and-incremental</div>
<div class="line">    update-types: only-full</div>
<div class="line">    update-interval: 180s</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md69"></a>
Update intervals</h2>
<p><code>update-interval</code> is the time interval between the <code>Update</code> calls. In particular this means:</p><ul>
<li><code>Update</code> is not called concurrently</li>
<li>Only with <code>update-jitter: 0s</code> and <code>is-strong-period: true</code> updates follow a strict schedule.</li>
</ul>
<p><code>full-update-interval</code> is the minimum interval between <code>full</code> updates in <code>full-and-incremental</code> cache. With each update, the cache checks if <code>full-update-interval</code> of the time has passed since the previous <code>full</code> update, and if it has passed, the current update will be <code>full</code>.</p>
<p><code>update-jitter</code> describes the spread in the delay between cache updates. It is especially useful in the case of heavy caches, which significantly load the database/remote with their updates. Adding a random delay spreads the cache updates of various instances over time, thereby removing the peak load on the database/remote.</p>
<h1><a class="anchor" id="autotoc_md70"></a>
Fault Tolerance</h1>
<p>The user can get the current cache snapshot regardless of the current state of the database/remote from which the cache is being poured, provided that at least once the cache update worked correctly. The user is working with a local copy, which may be slightly behind the original in time. In case of problems with the database/remote the cache update may finish with an error (i.e. the <code>Update</code> method will throw an exception), leaving the local cache unchanged.</p>
<p>By default, the first cache update must be completed successfully to set the initial value. If the first update fails with an error, i.e. the update throws an exception, then this leads to an exception in the cache component constructor and to the service shutdown. There are two ways to change this behavior:</p><ol type="1">
<li><a class="el" href="../../dc/d08/md_en_userver_cache-dumps.html">By enabling dumps</a>, in this case the cache starts with the state stored in the dump. If there is no dump, the service will still fall when the first update fails. You can overcome this through next clause</li>
<li>By giving a permission to load without the first update. In case of auxiliary cache, it may be useful to leave the cache in an error state and asynchronously update it after the service start. To do this, specify <code>first-update-fail-ok</code> in the component settings: <div class="fragment"><div class="line">yaml</div>
<div class="line">  first-update-fail-ok-cache:</div>
<div class="line">  update-interval: 60s</div>
<div class="line">  update-jitter: 10s</div>
<div class="line">  full-update-interval: 1000s</div>
<div class="line">  first-update-fail-ok: true</div>
</div><!-- fragment --></li>
</ol>
<p>If the "cache has no data" situation is normal for you and you want to handle it yourself, you can override the <code>MayReturnNull()</code> method in the cache so that it returns <code>true</code> (by default <code>false</code>). In this case, instead of an exception, you will get an empty smart pointer (<code>nullptr</code>).</p>
<h1><a class="anchor" id="autotoc_md71"></a>
Access synchronization, versioning, memory consumption</h1>
<p>Cache implementation does not block numerous concurrent cache readers while doing a background cache update. In case of time consuming work with cache data, users may encounter the fact that different readers work with different versions of the data. As a result, more than two versions of the cache data can coexist at the same time. Memory and other resources of old data versions are released either when updating the cache or when the background garbage collector collects the garbage. The frequency of garbage collection is regulated via the <code>additional-cleanup-interval</code> parameter.</p>
<p>The total amount of memory for the cache can be approximately calculated by the formula: </p><div class="fragment"><div class="line">Total cache memory = cache data memory * ([user time / update interval] + 1)</div>
</div><!-- fragment --><p>where:</p><ul>
<li><code>cache data memory</code> is the maximum size of one cache copy</li>
<li><code>update interval</code> - minimum cache update period</li>
<li><code>user time</code> - the maximum time that users hold a copy of the cache (i.e. the lifetime of the <code>Get()</code> result)</li>
</ul>
<p>For example, if the cache data occupies 1 GB, the cache is updated every 4 seconds, and the handle works for 9 seconds, then the total memory consumption of the cache is <code>1 GB * ([9/4]+1) = 4 GB</code>.</p>
<p>A commonly used technique to solve the problem of excessive memory consumption for large caches is splitting the cache into chunks.</p>
<h1><a class="anchor" id="autotoc_md72"></a>
Heavy Caches</h1>
<p>Updating caches can significantly load the CPU, for example, when parsing data from a database. If such a load lasts for a significant time without context switches (several tens of milliseconds), then this may negatively affect the timings of the service. Sometimes a similar problem occurs not only when forming a new cache snapshot, but also in the callback of a cache subscription, for example, when forming an additional cache index. There are several ways to solve this problem.</p>
<p><b>The first option</b>. Increase the number of CPU cores. The more cores you have in the service, the less CPU fraction is used by caches and the better is the efficiency of the service. On the contrary, when splitting a cluster into small containers with a small number of cores, the number of cache instances in the cluster increases, which is why the consumed by caches CPU fraction increases.</p>
<p><b>The second option</b>. Add context switching. If you call <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield()</a> every 1-2ms, then the framework engine has time to execute the other ready for execution coroutines and the queue of ready coroutines does not grow to undesirable values. To simplify working with <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield</a>, it is recommended to use <a class="el" href="../../d9/df3/classutils_1_1CpuRelax.html">utils::CpuRelax</a> rather than calling <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield()</a> manually.</p>
<h1><a class="anchor" id="autotoc_md73"></a>
Specializations for DB</h1>
<p>The cache is implemented by inheriting from <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a>. There are specializations for databases:</p><ul>
<li>MongoCache</li>
<li><a class="el" href="../../d9/dde/pg_cache.html">Caching Component for PostgreSQL</a></li>
</ul>
<p>To write your own cache, you need to override the <a class="el" href="../../da/df8/classcache_1_1CacheUpdateTrait.html#aeedbce6882ed3f9e32ad663be728fe50" title="Forces a cache update of specified type.">cache::CacheUpdateTrait::Update</a>, implement Full and Incremental updates. In Update(), don't forget to put down metrics for the <code>stats_scope</code> object, describing how many objects were read, how many parsing errors there were, and how many elements are in the final cache.</p>
<h1><a class="anchor" id="autotoc_md74"></a>
Parallel loading</h1>
<p>Cache components, like other components, are loaded in parallel. This allows you to speed up the loading of the service in the case of numerous heavy caches.</p>
<h1><a class="anchor" id="autotoc_md75"></a>
Metrics</h1>
<p>Each cache automatically collects metrics: </p><div class="fragment"><div class="line">...</div>
<div class="line">cache.simple-dumped-cache.dump.is-loaded-from-dump 1</div>
<div class="line">cache.simple-dumped-cache.dump.is-current-from-dump 0</div>
<div class="line">cache.simple-dumped-cache.dump.last-nontrivial-write.duration-ms 17</div>
<div class="line">cache.simple-dumped-cache.dump.last-nontrivial-write.size-kb 0</div>
<div class="line">cache.simple-dumped-cache.dump.last-nontrivial-write.time-from-start-ms 927</div>
<div class="line">cache.simple-dumped-cache.dump.load-duration-ms 9</div>
<div class="line">...</div>
<div class="line">cache.taxi-config.any.documents.parse_failures 0</div>
<div class="line">cache.taxi-config.any.documents.read_count 1257984</div>
<div class="line">cache.taxi-config.any.time.last-update-duration-ms 45</div>
<div class="line">cache.taxi-config.any.time.time-from-last-successful-start-ms 4687</div>
<div class="line">cache.taxi-config.any.time.time-from-last-update-start-ms 4687</div>
<div class="line">cache.taxi-config.any.update.attempts_count 12290</div>
<div class="line">cache.taxi-config.any.update.failures_count 0</div>
<div class="line">cache.taxi-config.any.update.no_changes_count 11294</div>
<div class="line">cache.taxi-config.current-documents-count 1271</div>
<div class="line">cache.taxi-config.dump.is-loaded-from-dump 0</div>
<div class="line">cache.taxi-config.full.documents.parse_failures 0</div>
<div class="line">cache.taxi-config.full.documents.read_count 1249139</div>
<div class="line">cache.taxi-config.full.time.last-update-duration-ms 45</div>
<div class="line">cache.taxi-config.full.time.time-from-last-successful-start-ms 39832</div>
<div class="line">cache.taxi-config.full.time.time-from-last-update-start-ms 39832</div>
<div class="line">cache.taxi-config.full.update.attempts_count 989</div>
<div class="line">cache.taxi-config.full.update.failures_count 0</div>
<div class="line">cache.taxi-config.full.update.no_changes_count 0</div>
<div class="line">cache.taxi-config.incremental.documents.parse_failures 0</div>
<div class="line">cache.taxi-config.incremental.documents.read_count 8845</div>
<div class="line">cache.taxi-config.incremental.time.last-update-duration-ms 1</div>
<div class="line">cache.taxi-config.incremental.time.time-from-last-successful-start-ms 4687</div>
<div class="line">cache.taxi-config.incremental.time.time-from-last-update-start-ms 4687</div>
<div class="line">cache.taxi-config.incremental.update.attempts_count 11301</div>
<div class="line">cache.taxi-config.incremental.update.failures_count 0</div>
<div class="line">cache.taxi-config.incremental.update.no_changes_count 11294</div>
<div class="line">...</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">⚒ Редактировать страницу</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "а":"a", "б":"b", "в":"v", "г":"g", "д":"d", "е":"e", "ё":"jo", "ж":"zh",
    "з":"z", "и":"i", "й":"jj", "к":"k", "л":"l", "м":"m", "н":"n", "о":"o",
    "п":"p", "р":"r", "с":"s", "т":"t", "у":"u", "ф":"f", "х":"x", "ц":"c",
    "ч":"ch", "ш":"sh", "щ":"shh", "ъ":"\'", "ы":"y", "ь":"\'", "э":"je",
    "ю":"ju", "я":"ja"
};
const DOXYGEN_DIAMOND_STRING = '◆\u00A0' // ◆&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '•&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">🔗</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
