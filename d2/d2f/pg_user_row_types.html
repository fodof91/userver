<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: uPg: Typed PostgreSQL results</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">uPg: Typed PostgreSQL results </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="../../d0/d5b/classstorages_1_1postgres_1_1ResultSet.html" title="PostgreSQL result set.">ResultSet</a> provides access to a generic PostgreSQL result buffer wrapper with access to individual column buffers and means to parse the buffers into a certain type.</p>
<p>For a user that wishes to get the results in a form of a sequence or a container of C++ tuples or structures, the driver provides a way to coerce the generic result set into a typed result set or a container of tuples or structures that fulfill certain conditions.</p>
<p><a class="el" href="../../df/d29/classstorages_1_1postgres_1_1TypedResultSet.html">TypedResultSet</a> provides container interface for typed result rows for iteration or random access without converting all the result set at once. The iterators in the <a class="el" href="../../df/d29/classstorages_1_1postgres_1_1TypedResultSet.html">TypedResultSet</a> satisfy requirements for a constant RandomAccessIterator with the exception of dereferencing iterators.</p>
<dl class="section warning"><dt>Warning</dt><dd>The operator* of the iterators returns value (not a reference to it) and the iterators don't have the operator-&gt;.</dd></dl>
<dl class="section user"><dt>Data row extraction</dt><dd></dd></dl>
<p>The data rows can be obtained as:</p><ul>
<li>std::tuple;</li>
<li>aggregate class as is;</li>
<li>non-aggregate class with some augmentation.</li>
</ul>
<p>Data members of the tuple or the classes must be supported by the driver. For more information on supported data types please see <a class="el" href="../../d0/d89/pg_types.html">uPg: Supported data types</a></p>
<dl class="section user"><dt>std::tuple.</dt><dd></dd></dl>
<p>The first option is to convert <a class="el" href="../../d0/d5b/classstorages_1_1postgres_1_1ResultSet.html" title="PostgreSQL result set.">ResultSet</a>'s row to std::tuples.</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> MyRowType = std::tuple&lt;int, string&gt;;</div>
<div class="line"><span class="keyword">auto</span> trx = ...;</div>
<div class="line"><span class="keyword">auto</span> generic_result = trx.Execute(<span class="stringliteral">&quot;select a, b from my_table&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> iteration = generic_result.AsSetOf&lt;MyRowType&gt;();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> row : iteration) {</div>
<div class="line">  static_assert(std::is_same_v&lt;decltype(row), MyRowType&gt;,</div>
<div class="line">      <span class="stringliteral">&quot;Iterate over tuples&quot;</span>);</div>
<div class="line">  <span class="keyword">auto</span> [a, b] = row;</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="stringliteral">&quot;; b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> data = geric_result.AsContainer&lt;std::vector&lt;MyRowType&gt;&gt;();</div>
</div><!-- fragment --><dl class="section user"><dt>Aggregate classes.</dt><dd></dd></dl>
<p>A data row can be coerced to an aggregate class.</p>
<p>An aggregate class (C++03 8.5.1 §1) is a class that with no base classes, no protected or private non-static data members, no user-declared constructors and no virtual functions.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyRowType {</div>
<div class="line">  <span class="keywordtype">int</span> a;</div>
<div class="line">  std::string b;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">auto</span> generic_result = trx.Execute(<span class="stringliteral">&quot;select a, b from my_table&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> iteration = generic_result.AsSetOf&lt;MyRowType&gt;();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> row : iteration) {</div>
<div class="line">  static_assert(std::is_same_v&lt;decltype(row), MyRowType&gt;,</div>
<div class="line">      <span class="stringliteral">&quot;Iterate over aggregate classes&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a = &quot;</span> &lt;&lt; row.a &lt;&lt; <span class="stringliteral">&quot;; b = &quot;</span> &lt;&lt; row.b &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> data = geric_result.AsContainer&lt;std::vector&lt;MyRowType&gt;&gt;();</div>
</div><!-- fragment --><dl class="section user"><dt>Non-aggregate classes.</dt><dd></dd></dl>
<p>Classes that do not satisfy the aggregate class requirements can be used to be created from data rows by providing additional <code>Introspect</code> non-static member function. The function should return a tuple of references to member data fields. The class must be default constructible.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyRowType {</div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> a_;</div>
<div class="line">  std::string b_;</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyRowType() = <span class="keywordflow">default</span>; <span class="comment">// default ctor is required</span></div>
<div class="line">  <span class="keyword">explicit</span> MyRowType(<span class="keywordtype">int</span> x);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> Introspect() {</div>
<div class="line">    <span class="keywordflow">return</span> std::tie(a_, b_);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">int</span> GetA() <span class="keyword">const</span>;</div>
<div class="line">  <span class="keyword">const</span> std::string&amp; GetB() <span class="keyword">const</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> generic_result = trx.Execute(<span class="stringliteral">&quot;select a, b from my_table&quot;</span>);</div>
<div class="line"><span class="keyword">auto</span> iteration = generic_result.AsSetOf&lt;MyRowType&gt;();</div>
<div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> row : iteration) {</div>
<div class="line">  static_assert(std::is_same_v&lt;decltype(row), MyRowType&gt;,</div>
<div class="line">      <span class="stringliteral">&quot;Iterate over non-aggregate classes&quot;</span>);</div>
<div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;a = &quot;</span> &lt;&lt; row.GetA() &lt;&lt; <span class="stringliteral">&quot;; b = &quot;</span> &lt;&lt; row.GetB() &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> data = geric_result.AsContainer&lt;std::vector&lt;MyRowType&gt;&gt;();</div>
</div><!-- fragment --><dl class="section user"><dt>Single-column result set</dt><dd></dd></dl>
<p>A single-column result set can be used to extract directly to the column type. User types mapped to PostgreSQL will work as well. If you need to extract the whole row into such a structure, you will need to disambiguate the call with the kRowTag.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> string_set = generic_result.AsSetOf&lt;std::string&gt;();</div>
<div class="line">std::string s = string_set[0];</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> string_vec = generic_result.AsContainer&lt;std::vector&lt;std::string&gt;&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract first column into the composite type</span></div>
<div class="line"><span class="keyword">auto</span> foo_set = generic_result.AsSetOf&lt;FooBar&gt;();</div>
<div class="line"><span class="keyword">auto</span> foo_vec = generic_result.AsContainer&lt;std::vector&lt;FooBar&gt;&gt;();</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Extract the whole row, disambiguation</span></div>
<div class="line"><span class="keyword">auto</span> foo_set = generic_result.AsSetOf&lt;FooBar&gt;(kRowTag);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">⚒ Редактировать страницу</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "а":"a", "б":"b", "в":"v", "г":"g", "д":"d", "е":"e", "ё":"jo", "ж":"zh",
    "з":"z", "и":"i", "й":"jj", "к":"k", "л":"l", "м":"m", "н":"n", "о":"o",
    "п":"p", "р":"r", "с":"s", "т":"t", "у":"u", "ф":"f", "х":"x", "ц":"c",
    "ч":"ch", "ш":"sh", "щ":"shh", "ъ":"\'", "ы":"y", "ь":"\'", "э":"je",
    "ю":"ju", "я":"ja"
};
const DOXYGEN_DIAMOND_STRING = '◆\u00A0' // ◆&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '•&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">🔗</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
