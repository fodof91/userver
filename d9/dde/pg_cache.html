<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: Caching Component for PostgreSQL</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Caching Component for PostgreSQL </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="pg_cc_configuration"></a>
Configuration</h1>
<p>PostgreSQL component name must be specified in <code>pgcomponent</code> configuration parameter.</p>
<p>Optionally the operation timeouts for cache loading can be specified.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Name </th><th class="markdownTableHeadNone">Description </th><th class="markdownTableHeadNone">Default value  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">full-update-op-timeout </td><td class="markdownTableBodyNone">timeout for a full update </td><td class="markdownTableBodyNone">1m  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">incremental-update-op-timeout </td><td class="markdownTableBodyNone">timeout for an incremental update </td><td class="markdownTableBodyNone">1s  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">update-correction </td><td class="markdownTableBodyNone">incremental update window adjustment </td><td class="markdownTableBodyNone">- (0 for caches with defined GetLastKnownUpdated)  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">chunk-size </td><td class="markdownTableBodyNone">number of rows to request from PostgreSQL, 0 to fetch all rows in one request </td><td class="markdownTableBodyNone">1000  </td></tr>
</table>
<h1><a class="anchor" id="pg_cc_cache_policy"></a>
Cache policy</h1>
<p>Cache policy is the template argument of component. Please see the following code snippet for documentation.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>example {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyStructure {</div>
<div class="line">  <span class="keywordtype">int</span> id;</div>
<div class="line">  std::string bar;</div>
<div class="line">  std::chrono::system_clock::time_point updated;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> get_id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> id; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PostgresExamplePolicy {</div>
<div class="line">  <span class="comment">// Name of caching policy component.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes**</span></div>
<div class="line">  <span class="keyword">static</span> constexpr std::string_view kName = <span class="stringliteral">&quot;my-pg-cache&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Object type.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes**</span></div>
<div class="line">  <span class="keyword">using</span> ValueType = MyStructure;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Key by which the object must be identified in cache.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// One of:</span></div>
<div class="line">  <span class="comment">// - A pointer-to-member in the object</span></div>
<div class="line">  <span class="comment">// - A pointer-to-member-function in the object that returns the key</span></div>
<div class="line">  <span class="comment">// - A pointer-to-function that takes the object and returns the key</span></div>
<div class="line">  <span class="comment">// - A lambda that takes the object and returns the key</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes**</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> kKeyMember = &amp;MyStructure::id;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Data retrieve query.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// The query should not contain any clauses after the `from` clause. Either</span></div>
<div class="line">  <span class="comment">// `kQuery` or `GetQuery` static member function must be defined.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes**</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kQuery =</div>
<div class="line">      <span class="stringliteral">&quot;select id, bar, updated from test.my_data&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Name of the field containing timestamp of an object.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// To turn off incremental updates, set the value to `nullptr`.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes**</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kUpdatedField = <span class="stringliteral">&quot;updated&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Type of the field containing timestamp of an object.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Specifies whether updated field should be treated as a timestamp</span></div>
<div class="line">  <span class="comment">// with or without timezone in database queries.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: **yes** if incremantal updates are used.</span></div>
<div class="line">  <span class="keyword">using</span> UpdatedFieldType = <a class="code" href="../../de/d6d/namespacestorages_1_1postgres.html#a69c43f80d0b6eec8f2205796e60fcc3e" title="Corresponds to TIMESTAMP WITH TIME ZONE (value in absolute time (no TZ offset)). Time zones are appli...">storages::postgres::TimePointTz</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Where clause of the query. Either `kWhere` or `GetWhere` can be defined.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: no</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kWhere = <span class="stringliteral">&quot;id &gt; 10&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Cache container type.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// It can be of any map type. The default is `unordered_map`, it is not</span></div>
<div class="line">  <span class="comment">// necessary to declare the DataType alias if you are OK with</span></div>
<div class="line">  <span class="comment">// `unordered_map`.</span></div>
<div class="line">  <span class="comment">// The key type must match the type of kKeyMember.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: no</span></div>
<div class="line">  <span class="keyword">using</span> CacheContainer = std::unordered_map&lt;int, MyStructure&gt;;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Cluster host selection flags to use when retrieving data.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Default value is storages::postgres::ClusterHostType::kSlave, at least one</span></div>
<div class="line">  <span class="comment">// cluster role must be present in flags.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: no</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> kClusterHostType =</div>
<div class="line">      <a class="code" href="../../de/d6d/namespacestorages_1_1postgres.html#a112991762e57633e6213c2cbbce7d62fa711876d1003646469de6eb5a7811927b">storages::postgres::ClusterHostType::kSlave</a>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Whether Get() is expected to return nullptr.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Default value is false, Get() will throw an exception instead of</span></div>
<div class="line">  <span class="comment">// returning nullptr.</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Required: no</span></div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keywordtype">bool</span> kMayReturnNull = <span class="keyword">false</span>;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace example</span></div>
</div><!-- fragment --><p> The query can be a std::string. But due to non-guaranteed order of static data members initialization, std::string should be returned from a static member function, please see the following code snippet.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>PostgresExamplePolicy4 {</div>
<div class="line">  <span class="keyword">static</span> constexpr std::string_view kName = <span class="stringliteral">&quot;my-pg-cache&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">using</span> ValueType = MyStructure;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> kKeyMember = &amp;MyStructure::id;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> std::string GetQuery() {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="stringliteral">&quot;select id, bar, updated from test.my_data&quot;</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kUpdatedField = <span class="stringliteral">&quot;updated&quot;</span>;</div>
<div class="line">  <span class="keyword">using</span> UpdatedFieldType =</div>
<div class="line">      <a class="code" href="../../de/d6d/namespacestorages_1_1postgres.html#a29cde9d1a6a088f6ef6ccf851b4ea8e2" title="Corresponds to TIMESTAMP WITHOUT TIME ZONE (value in absolute time (no TZ offset)).">storages::postgres::TimePoint</a>;  <span class="comment">// no time zone (should be avoided)</span></div>
<div class="line">};</div>
</div><!-- fragment --><p> Policy may have static function GetLastKnownUpdated. It should be used when new entries from database are taken via revision, identifier, or anything else, but not timestamp of the last update. If this function is supplied, new entries are taken from db with condition 'WHERE kUpdatedField &gt; GetLastKnownUpdated(cache_container)'. Otherwise, condition is 'WHERE kUpdatedField &gt; last_update - correction_'. See the following code snippet for an example of usage</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>MyStructureWithRevision {</div>
<div class="line">  <span class="keywordtype">int</span> id;</div>
<div class="line">  std::string bar;</div>
<div class="line">  std::chrono::system_clock::time_point updated;</div>
<div class="line">  int32_t revision;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> get_id()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> id; }</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>UserSpecificCache {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> insert_or_assign(<span class="keywordtype">int</span>, MyStructureWithRevision&amp;&amp; item) {</div>
<div class="line">    latest_revision_ = std::max(latest_revision_, item.revision);</div>
<div class="line">  }</div>
<div class="line">  <span class="keywordtype">size_t</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">int</span> GetLatestRevision()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> latest_revision_; }</div>
<div class="line"> </div>
<div class="line"> <span class="keyword">private</span>:</div>
<div class="line">  <span class="keywordtype">int</span> latest_revision_ = 0;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PostgresExamplePolicy3 {</div>
<div class="line">  <span class="keyword">using</span> ValueType = MyStructureWithRevision;</div>
<div class="line">  <span class="keyword">static</span> constexpr std::string_view kName = <span class="stringliteral">&quot;my-pg-cache&quot;</span>;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kQuery =</div>
<div class="line">      <span class="stringliteral">&quot;select id, bar, revision from test.my_data&quot;</span>;</div>
<div class="line">  <span class="keyword">using</span> CacheContainer = UserSpecificCache;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">const</span> <span class="keywordtype">char</span>* kUpdatedField = <span class="stringliteral">&quot;revision&quot;</span>;</div>
<div class="line">  <span class="keyword">using</span> UpdatedFieldType = int32_t;</div>
<div class="line">  <span class="keyword">static</span> constexpr <span class="keyword">auto</span> kKeyMember = &amp;MyStructureWithRevision::get_id;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Function to get last known revision/time</span></div>
<div class="line">  <span class="comment">//</span></div>
<div class="line">  <span class="comment">// Optional</span></div>
<div class="line">  <span class="comment">// If one wants to get cache updates not based on updated time, but, for</span></div>
<div class="line">  <span class="comment">// example, based on revision &gt; known_revision, this method should be used.</span></div>
<div class="line">  <span class="keyword">static</span> int32_t GetLastKnownUpdated(<span class="keyword">const</span> UserSpecificCache&amp; container) {</div>
<div class="line">    <span class="keywordflow">return</span> container.GetLatestRevision();</div>
<div class="line">  }</div>
<div class="line">};</div>
</div><!-- fragment --><p> In case one provides a custom CacheContainer within Policy, it is notified of Update completion via its public member function OnWritesDone, if any. See the following code snippet for an example of usage:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>UserSpecificCacheWithWriteNotification {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> insert_or_assign(<span class="keywordtype">int</span>, MyStructure&amp;&amp;) {}</div>
<div class="line">  <span class="keywordtype">size_t</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordtype">void</span> OnWritesDone() {}</div>
<div class="line">};</div>
</div><!-- fragment --> <h1><a class="anchor" id="pg_cc_forward_declaration"></a>
Forward Declaration</h1>
<p>To forward declare a cache you can forward declare a trait and include <a class="el" href="../../dd/d4f/base__postgres__cache__fwd_8hpp.html" title="Forward declaration of the components::PostgreCache.">userver/cache/base_postgres_cache_fwd.hpp</a> header. It is also useful to forward declare the cache value type.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma once</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span>  <span class="comment">// for std::shared_ptr</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../dd/d4f/base__postgres__cache__fwd_8hpp.html" title="Forward declaration of the components::PostgreCache.">userver/cache/base_postgres_cache_fwd.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">USERVER_NAMESPACE_BEGIN</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>example {  <span class="comment">// replace with a namespace of your trait</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>PostgresExamplePolicy;</div>
<div class="line"><span class="keyword">struct </span>MyStructure;</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace example</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>caches {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using</span> MyCache1 = <a class="code" href="../../d2/d8d/classcomponents_1_1PostgreCache.html" title="Caching component for PostgreSQL derived from components::CachingComponentBase.">components::PostgreCache&lt;example::PostgresExamplePolicy&gt;</a>;</div>
<div class="line"><span class="keyword">using</span> MyCache1Data = std::shared_ptr&lt;const example::MyStructure&gt;;</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace caches</span></div>
</div><!-- fragment --></div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">⚒ Редактировать страницу</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "а":"a", "б":"b", "в":"v", "г":"g", "д":"d", "е":"e", "ё":"jo", "ж":"zh",
    "з":"z", "и":"i", "й":"jj", "к":"k", "л":"l", "м":"m", "н":"n", "о":"o",
    "п":"p", "р":"r", "с":"s", "т":"t", "у":"u", "ф":"f", "х":"x", "ц":"c",
    "ч":"ch", "ш":"sh", "щ":"shh", "ъ":"\'", "ы":"y", "ь":"\'", "э":"je",
    "ю":"ju", "я":"ja"
};
const DOXYGEN_DIAMOND_STRING = '◆\u00A0' // ◆&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '•&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">🔗</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
