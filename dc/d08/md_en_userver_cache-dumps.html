<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: Local cache dumps</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Local cache dumps </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Cache components derived from <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> support cache dumps. If enabled, the cache periodically writes a snapshot of the data to a dump file. When a cache component starts and a suitable dump exists, the cache reads a dump and skips the synchronous <code>Update</code>.</p>
<p>Advantages:</p><ul>
<li>Faster service start: the service no longer waits for the first synchronous <code>Update</code> that may query a database or make some other network requests.</li>
<li>Better fault tolerance: the service now boots successfully even if the first update fails.</li>
</ul>
<p>Disadvantages:</p><ul>
<li>CPU time is spent on periodic serialization of data and writing to the dump file.</li>
<li>Disk accesses consume the IO quota, which can negatively affect other disk users (for example, logging or other caches).</li>
</ul>
<h1><a class="anchor" id="autotoc_md56"></a>
How to set up cache dumps</h1>
<p>0. Make a caching component, for example as in <a class="el" href="../../d7/d8e/md_en_userver_tutorial_http_caching.html">Pre-caching data from HTTP remote</a>.</p><ol type="1">
<li>Ensure that your data type is dumpable. To do that, add a static_assert into the header file of your caching component or near your type declaration: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d0d/core_2include_2userver_2dump_2meta_8hpp.html" title="Provides dump::kIsDumpable and includes userver/dump/fwd.hpp.">userver/dump/meta.hpp</a>&gt;</span>  <span class="comment">// for forward declarations and kIsDumpable</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>dummy {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>SampleType {</div>
<div class="line">  std::vector&lt;std::string&gt; foo;</div>
<div class="line">  std::int64_t bar{};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/d72/namespacedump.html#a69747c1867eb871ee01da10e663d7de6" title="Aggregates dumping support.">Write</a>(<a class="code" href="../../df/d09/classdump_1_1Writer.html" title="A general interface for binary data output.">dump::Writer</a>&amp; writer, <span class="keyword">const</span> SampleType&amp; value);</div>
<div class="line"> </div>
<div class="line">SampleType <a class="code" href="../../d8/d72/namespacedump.html#a5ac3b3940aeb655783af172fa2c051e9" title="Aggregates deserialization from dump support.">Read</a>(<a class="code" href="../../d2/d03/classdump_1_1Reader.html" title="A general interface for binary data input.">dump::Reader</a>&amp; reader, <a class="code" href="../../dc/d52/structdump_1_1To.html" title="A marker type used in ADL-found Read">dump::To&lt;SampleType&gt;</a>);</div>
<div class="line"> </div>
<div class="line">static_assert(dump::CheckDumpable&lt;SampleType&gt;());</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace dummy</span></div>
</div><!-- fragment --></li>
<li>If the assertion fails:<ul>
<li><a class="el" href="../../dc/d08/md_en_userver_cache-dumps.html#dump_serialization_guide">Implement serialization</a></li>
<li><a class="el" href="../../dc/d08/md_en_userver_cache-dumps.html#dump_testing_guide">Write unit tests for it</a></li>
</ul>
</li>
<li>Enable dumps in the static configuration of your service: <div class="fragment"><div class="line">yaml</div>
<div class="line">components_manager:</div>
<div class="line">  components:</div>
<div class="line">    simple-dumped-cache:</div>
<div class="line">      update-types: only-full</div>
<div class="line">      update-interval: 1m</div>
<div class="line">      # that&#39;s how we turn it on</div>
<div class="line">      dump:</div>
<div class="line">        enable: true</div>
<div class="line">        world-readable: false</div>
<div class="line">        format-version: 0</div>
<div class="line">        first-update-mode: required</div>
<div class="line">        first-update-type: full</div>
</div><!-- fragment --></li>
</ol>
<p><a class="anchor" id="dump_serialization_guide"></a></p>
<h1><a class="anchor" id="autotoc_md57"></a>
Implementing serialization (&lt;tt&gt;Write&lt;/tt&gt; / &lt;tt&gt;Read&lt;/tt&gt;)</h1>
<p>In order for a data type to be serialized for cache dumps the <code>Write</code> and <code>Read</code> functions must be implemented in the namespace of the type or in <code>namespace dump</code>:</p>
<ul>
<li>Basic types already have the required functions defined in <a class="el" href="../../d2/db0/group__userver__dump__read__write.html">various headers</a>:<ul>
<li>Integers, floats, doubles, strings, <code>std::chrono</code>, <code>enum</code>, <code>uuid</code> in <code>&lt;<a class="el" href="../../d8/d6b/core_2include_2userver_2dump_2common_8hpp.html" title="Serialization and deserialization of integral, floating point, string, std::chrono,...">userver/dump/common.hpp</a>&gt;</code></li>
<li>C++ Standard Library and Boost containers, <code>std::optional</code>, <code><a class="el" href="../../d4/d67/classutils_1_1StrongTypedef.html" title="Strong typedef for a type T.">utils::StrongTypedef</a></code>, <code>std::{unique,shared}_ptr</code> in <code>&lt;<a class="el" href="../../df/d8a/core_2include_2userver_2dump_2common__containers_8hpp.html" title="Dump support for C++ Standard Library and Boost containers, std::optional, utils::StrongTypedef,...">userver/dump/common_containers.hpp</a>&gt;</code></li>
<li>Trivial structures (aggregates) in <code>&lt;<a class="el" href="../../d8/deb/aggregates_8hpp.html" title="Dumping support for aggregates.">userver/dump/aggregates.hpp</a>&gt;</code>, but you will have to enable dumps manually: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d8/deb/aggregates_8hpp.html" title="Dumping support for aggregates.">userver/dump/aggregates.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>some_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyStruct {</div>
<div class="line">  std::int16_t some_field;</div>
<div class="line">  std::string some_other_field;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace some_namespace</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Enable dumping of the aggregate</span></div>
<div class="line"><span class="keyword">template</span> &lt;&gt;</div>
<div class="line"><span class="keyword">struct </span><a class="code" href="../../d2/d4c/structdump_1_1IsDumpedAggregate.html">dump::IsDumpedAggregate</a>&lt;some_namespace::MyStruct&gt;;</div>
</div><!-- fragment --></li>
</ul>
</li>
<li>For more complex user types it is recommended to place only declarations in the header file to avoid unnecessary includes leaking into all the translation units that use the type: <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;cstdint&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;string&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d9/d0d/core_2include_2userver_2dump_2meta_8hpp.html" title="Provides dump::kIsDumpable and includes userver/dump/fwd.hpp.">userver/dump/meta.hpp</a>&gt;</span>  <span class="comment">// for forward declarations and kIsDumpable</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>dummy {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>SampleType {</div>
<div class="line">  std::vector&lt;std::string&gt; foo;</div>
<div class="line">  std::int64_t bar{};</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/d72/namespacedump.html#a69747c1867eb871ee01da10e663d7de6" title="Aggregates dumping support.">Write</a>(<a class="code" href="../../df/d09/classdump_1_1Writer.html" title="A general interface for binary data output.">dump::Writer</a>&amp; writer, <span class="keyword">const</span> SampleType&amp; value);</div>
<div class="line"> </div>
<div class="line">SampleType <a class="code" href="../../d8/d72/namespacedump.html#a5ac3b3940aeb655783af172fa2c051e9" title="Aggregates deserialization from dump support.">Read</a>(<a class="code" href="../../d2/d03/classdump_1_1Reader.html" title="A general interface for binary data input.">dump::Reader</a>&amp; reader, <a class="code" href="../../dc/d52/structdump_1_1To.html" title="A marker type used in ADL-found Read">dump::To&lt;SampleType&gt;</a>);</div>
<div class="line"> </div>
<div class="line">static_assert(dump::CheckDumpable&lt;SampleType&gt;());</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace dummy</span></div>
</div><!-- fragment --> Actual definitions should go to the source file: <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;class_serialization_sample_test.hpp&quot;</span>  <span class="comment">// for dummy::SampleType</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d8/d6b/core_2include_2userver_2dump_2common_8hpp.html" title="Serialization and deserialization of integral, floating point, string, std::chrono,...">userver/dump/common.hpp</a>&gt;</span>             <span class="comment">// for int, string dump</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../df/d8a/core_2include_2userver_2dump_2common__containers_8hpp.html" title="Dump support for C++ Standard Library and Boost containers, std::optional, utils::StrongTypedef,...">userver/dump/common_containers.hpp</a>&gt;</span>  <span class="comment">// for vector dump</span></div>
<div class="line"><span class="preprocessor">#include &lt;userver/dump/operations.hpp&gt;</span>         <span class="comment">// for Writer/Reader</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>dummy {</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> <a class="code" href="../../d8/d72/namespacedump.html#a69747c1867eb871ee01da10e663d7de6" title="Aggregates dumping support.">Write</a>(<a class="code" href="../../df/d09/classdump_1_1Writer.html" title="A general interface for binary data output.">dump::Writer</a>&amp; writer, <span class="keyword">const</span> SampleType&amp; value) {</div>
<div class="line">  writer.Write(value.foo);</div>
<div class="line">  writer.Write(value.bar);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">SampleType <a class="code" href="../../d8/d72/namespacedump.html#a5ac3b3940aeb655783af172fa2c051e9" title="Aggregates deserialization from dump support.">Read</a>(<a class="code" href="../../d2/d03/classdump_1_1Reader.html" title="A general interface for binary data input.">dump::Reader</a>&amp; reader, <a class="code" href="../../dc/d52/structdump_1_1To.html" title="A marker type used in ADL-found Read">dump::To&lt;SampleType&gt;</a>) {</div>
<div class="line">  SampleType value;</div>
<div class="line">  value.foo = reader.<a class="code" href="../../d2/d03/classdump_1_1Reader.html#aa50754192ec845b898e1b92827f51c2f" title="Reads binary data.">Read</a>&lt;std::vector&lt;std::string&gt;&gt;();</div>
<div class="line">  value.bar = reader.<a class="code" href="../../d2/d03/classdump_1_1Reader.html#aa50754192ec845b898e1b92827f51c2f" title="Reads binary data.">Read</a>&lt;std::int64_t&gt;();</div>
<div class="line">  <span class="keywordflow">return</span> value;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace dummy</span></div>
</div><!-- fragment --></li>
<li>If JSON, protobuf or flatbuffers serialization is already implemented for the structure, you can use it in <code>Write</code>/<code>Read</code> if it suites your requirements.</li>
</ul>
<h2><a class="anchor" id="autotoc_md58"></a>
Recommendations</h2>
<ol type="1">
<li>Place <code>Write</code>/<code>Read</code> function declarations for your own types:<ul>
<li>in the <code>namespace</code> of the type, not into <code>namespace dump</code></li>
<li>in the same header, next to the type definition</li>
</ul>
</li>
<li>Place serialization of third party types:<ul>
<li>in <code>namespace dump</code></li>
<li>if serialization may be useful to others and does not add source dependencies, it is worth making a PR into userver</li>
</ul>
</li>
<li>When implementing serialization for multiple types, place functions in the order <code>Write1, Read1, Write2, Read2, ...</code></li>
<li>Avoid using <code>Write/Read</code> functions by ADL (argument dependent lookup), prefer calling <code>writer.Write(value)</code> or <code>reader.Read&lt;T&gt;()</code>.</li>
</ol>
<p><a class="anchor" id="dump_testing_guide"></a></p>
<h1><a class="anchor" id="autotoc_md59"></a>
Testing serialization</h1>
<p>If you have written your own <code>Write/Read</code> functions, write <code>utest</code> tests for them using <code>&lt;<a class="el" href="../../d7/d7c/testing_2include_2userver_2dump_2test__helpers_8hpp_source.html">userver/dump/test_helpers.hpp</a>&gt;</code>. If the data type supports <code>operator==</code>, it is sufficient to use <a class="el" href="../../d8/d72/namespacedump.html#a5c1815326215e1245333b25f126d9067">dump::TestWriteReadCycle</a>.</p>
<h1><a class="anchor" id="autotoc_md60"></a>
Encryption of the dump file</h1>
<p>By default, the data in the file is stored using an insecure format (binary or JSON). A user with access to the dump file can restore its contents. If the dump file is compromised, a malicious user can gain access to the data. This may be undesirable in the case of caches that store personal or other private data. For such caches, you can enable encryption of the dump file. Dump encryption is disabled by default.</p>
<p>The <a class="el" href="../../df/dd1/classcomponents_1_1CachingComponentBase.html" title="Base class for caching components.">components::CachingComponentBase</a> uses the AES-GCM-256 encryption algorithm if the encryption is enabled. To enable encryption, do the following:</p><ol type="1">
<li>In the static configuration for the cache, set <code>dump.encrypted=true</code>: <div class="fragment"><div class="line">yaml</div>
<div class="line">components_manager:</div>
<div class="line">  components:</div>
<div class="line">    your-caching-component:</div>
<div class="line">      dump:</div>
<div class="line">        encrypted: true</div>
</div><!-- fragment --></li>
<li>Place a secret for encoding and decoding into <code>CACHE_DUMP_SECRET_KEYS</code> section of the <a class="el" href="../../da/dc7/classcomponents_1_1Secdist.html" title="Component that stores security related data (keys, passwords, ...).">components::Secdist</a> file. Use the name of your cache component as a JSON key and the secret as a JSON value: ``` json { "CACHE_DUMP_SECRET_KEYS": { "you-cache-component-name": "your-base64encoded-secret-key" } } ```</li>
</ol>
<h1><a class="anchor" id="autotoc_md61"></a>
Dump Settings</h1>
<p>Static settings for dumps are set in the <code>dump</code> subsection of the cache component. All the <code>dump</code> options are described in the <a class="el" href="../../d8/d4c/classdump_1_1Dumper.html" title="Manages dumps of a cache-like component.">dump::Dumper</a>.</p>
<p>An example with all the options:</p>
<div class="fragment"><div class="line">yaml</div>
<div class="line">components_manager:</div>
<div class="line">  components:</div>
<div class="line">  simple-dumped-cache:</div>
<div class="line">    update-types: only-incremental</div>
<div class="line">    update-interval: 1m</div>
<div class="line">    dump:</div>
<div class="line">      enable: true</div>
<div class="line">      world-readable: false</div>
<div class="line">      format-version: 4</div>
<div class="line">      first-update-mode: skip</div>
<div class="line">      first-update-type: incremental</div>
<div class="line">      max-age: 60m</div>
<div class="line">      max-count: 1</div>
<div class="line">      min-interval: 3m</div>
<div class="line">      fs-task-processor: my-task-processor</div>
<div class="line">      wait-for-first-update: true</div>
<div class="line">      encrypted: false</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md62"></a>
Dynamic configuration of dumps</h1>
<p>A subset of dump settings could be overridden by the dynamic configuration <a class="el" href="../../dd/d2c/md_en_schemas_dynamic_configs.html#USERVER_DUMPS">USERVER_DUMPS</a>.</p>
<p>If you omit setting the dynamic configuration (or do not describe some cache in <a class="el" href="../../dd/d2c/md_en_schemas_dynamic_configs.html#USERVER_DUMPS">USERVER_DUMPS</a>), the value from the static configuration is used. To reset to the default value, you need to specify <code>null</code> in the dynamic configuration.</p>
<p>Example:</p>
<div class="fragment"><div class="line">json</div>
<div class="line">{</div>
<div class="line">  &quot;your-cache-component&quot;: {</div>
<div class="line">    &quot;dumps-enabled&quot;: true,</div>
<div class="line">    &quot;min-dump-interval-ms&quot;: 600000</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md63"></a>
Implementation details</h1>
<h2><a class="anchor" id="autotoc_md64"></a>
IO</h2>
<ul>
<li>Disk operations are performed asynchronously with <code>Update</code> in a separate <code>fs-task-processor</code>. <code>Write</code> and <code>Read</code> are also called in that task processor.</li>
<li>No more than one dump could be written at the same time. If after an <code>Update</code> the previous write to the dump has not completed, the new write operation is skipped.</li>
<li>While writing the dump <a class="el" href="../../de/d7a/classdump_1_1FileWriter.html" title="A handle to a dump file. File operations block the thread.">dump::FileWriter</a> periodically calls to <a class="el" href="../../dc/d3f/namespaceengine.html#a142b0ca27e383ae38f52cac01692a8d0" title="Suspends execution for a brief period of time, possibly allowing other tasks to execute.">engine::Yield</a> to avoid blocking the thread for a long time</li>
<li>For each cache, a subdirectory with the name of the cache is created</li>
<li>The dump name contains UTC time with microsecond precision and <code>format-version</code>, for example <code>2020-10-28T174608.907090Z-v0</code></li>
<li>Dump is updated atomically. A new <code>.tmp</code> file is created, flushed on the disk and atomically renamed.</li>
<li>Permissions for all the created directories are <code>0755</code></li>
<li>Permissions for the dump files are either <code>0400</code> or <code>0444</code>, depending on the <code>world-readable</code> setting.</li>
</ul>
<h2><a class="anchor" id="autotoc_md65"></a>
Data format</h2>
<ul>
<li>The dump data format is a binary stream of fixed-size structures and strings in the "size, data" format.</li>
<li>Sizes and other integers are compressed. <code>0</code> and other small numbers occupy 1 byte. Large and negative numbers take up to 9 bytes</li>
<li>Empty <code>std::string</code>, <code>std::optional</code>, containers occupy 1 byte</li>
<li>Optimization of default values is not performed</li>
<li>Format of the dump is platform-independent</li>
</ul>
<h1><a class="anchor" id="autotoc_md66"></a>
Nuances and pitfalls</h1>
<ul>
<li>If an empty value is stored in the cache (for example, due to calling CachingComponentBase::Clear()), the cache will gladly replace the old dump with a new empty dump. You can deal with this in the following ways:<ul>
<li>Do not use Clear(). The cache expects that if there is no data, it is <code>nullptr</code> that lies there. To prevent this from causing an exception, you will have to redefine <code>void MayReturnNull() override { return true; }</code> and <code>first-update-fail-ok: true</code></li>
</ul>
</li>
<li>Redefine <code>Write</code>/<code>Read</code> for your data type to throw <code><a class="el" href="../../d9/d52/classcache_1_1EmptyCacheError.html">cache::EmptyCacheError</a></code> when the cache value is empty. If there is a standard datatype in the cache, you will have to wrap it in a <code>struct</code> to define a custom <code>Write</code>/<code>Read</code>.</li>
<li>If multiple <code>std::shared_ptr</code>s for the same object are stored in the same cache snapshot, they will point to separate copies of this object after the dump is loaded.</li>
<li>In order not to copy a large string when deserializing JSON, flatbuffers, etc., you can use <code>&lt;<a class="el" href="../../dd/d0b/unsafe_8hpp_source.html">userver/dump/unsafe.hpp</a>&gt;</code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">⚒ Редактировать страницу</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "а":"a", "б":"b", "в":"v", "г":"g", "д":"d", "е":"e", "ё":"jo", "ж":"zh",
    "з":"z", "и":"i", "й":"jj", "к":"k", "л":"l", "м":"m", "н":"n", "о":"o",
    "п":"p", "р":"r", "с":"s", "т":"t", "у":"u", "ф":"f", "х":"x", "ц":"c",
    "ч":"ch", "ш":"sh", "щ":"shh", "ъ":"\'", "ы":"y", "ь":"\'", "э":"je",
    "ю":"ju", "я":"ja"
};
const DOXYGEN_DIAMOND_STRING = '◆\u00A0' // ◆&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '•&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">🔗</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
