<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: Formats (JSON, YAML, BSON, ...)</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Formats (JSON, YAML, BSON, ...) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Userver provides classes for reading, working with, and serializing various data formats. Classes for different formats have an almost identical interface. There are common points for customizing parsers and serializers of custom types.</p>
<h2><a class="anchor" id="autotoc_md101"></a>
formats::*::Value</h2>
<p>Classes <code><a class="el" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a></code>, <code><a class="el" href="../../db/d67/classformats_1_1bson_1_1Value.html" title="Non-mutable BSON value representation.">formats::bson::Value</a></code>, <code><a class="el" href="../../d3/d6c/classyaml__config_1_1YamlConfig.html" title="Datatype that represents YAML with substituted variables.">yaml_config::YamlConfig</a></code> and <code><a class="el" href="../../da/dc1/classformats_1_1yaml_1_1Value.html" title="Non-mutable YAML value representation.">formats::yaml::Value</a></code> are intended for non-modifying work with formats (in other words, for reading data).</p>
<p>Usage Example:</p>
<div class="fragment"><div class="line">  <span class="comment">// #include &lt;userver/formats/json.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">  <a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> json = <a class="code" href="../../de/da1/namespaceformats_1_1json.html#aebd74445be0a82a8db7976c19324f098" title="Parse JSON from string.">formats::json::FromString</a>(R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">    &quot;key1&quot;: 1,</span></div>
<div class="line"><span class="stringliteral">    &quot;key2&quot;: {&quot;key3&quot;:&quot;val&quot;}</span></div>
<div class="line"><span class="stringliteral">  })&quot;);</span></div>
<div class="line"><span class="stringliteral"></span> </div>
<div class="line"><span class="stringliteral">  </span><span class="keyword">const</span> <span class="keyword">auto</span> key1 = json[<span class="stringliteral">&quot;key1&quot;</span>].<a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html#a4383138b64646d372ab3990e38e2fc62" title="Returns value of *this converted to T.">As</a>&lt;<span class="keywordtype">int</span>&gt;();</div>
<div class="line">  ASSERT_EQ(key1, 1);</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> key3 = json[<span class="stringliteral">&quot;key2&quot;</span>][<span class="stringliteral">&quot;key3&quot;</span>].<a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html#a4383138b64646d372ab3990e38e2fc62" title="Returns value of *this converted to T.">As</a>&lt;std::string&gt;();</div>
<div class="line">  ASSERT_EQ(key3, <span class="stringliteral">&quot;val&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md102"></a>
Customization of formats::*::Value::As&lt;T&gt;()</h2>
<p>In order for <code>formats::*::Value</code> to be able to represent data as a C++ type, you should write a special function <code>Parse</code> for that C++ type. <code>Parse</code> should be located in the namespace of the type or may be located in the <code><a class="el" href="../../d4/d6e/namespaceformats_1_1common.html" title="Common utilities for all the formats.">formats::common</a></code> namespace if the type comes from third-party library that you have no control of:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyKeyValue {</div>
<div class="line">  std::string field1;</div>
<div class="line">  <span class="keywordtype">int</span> field2;</div>
<div class="line">};</div>
<div class="line"><span class="comment">//  The function must be declared in the namespace of your type</span></div>
<div class="line">MyKeyValue Parse(<span class="keyword">const</span> <a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a>&amp; json,</div>
<div class="line">                 <a class="code" href="../../d6/dd1/structformats_1_1parse_1_1To.html">formats::parse::To&lt;MyKeyValue&gt;</a>) {</div>
<div class="line">  <span class="keywordflow">return</span> MyKeyValue{</div>
<div class="line">      json[<span class="stringliteral">&quot;field1&quot;</span>].<a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html#a4383138b64646d372ab3990e38e2fc62" title="Returns value of *this converted to T.">As</a>&lt;std::string&gt;(<span class="stringliteral">&quot;&quot;</span>),</div>
<div class="line">      json[<span class="stringliteral">&quot;field2&quot;</span>].As&lt;int&gt;(1),  <span class="comment">// return `1` if &quot;field2&quot; is missing</span></div>
<div class="line">  };</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(FormatsJson, ExampleUsageMyStruct) {</div>
<div class="line">  <a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> json = <a class="code" href="../../de/da1/namespaceformats_1_1json.html#aebd74445be0a82a8db7976c19324f098" title="Parse JSON from string.">formats::json::FromString</a>(R<span class="stringliteral">&quot;({</span></div>
<div class="line"><span class="stringliteral">    &quot;my_value&quot;: {</span></div>
<div class="line"><span class="stringliteral">        &quot;field1&quot;: &quot;one&quot;,</span></div>
<div class="line"><span class="stringliteral">        &quot;field2&quot;: 1</span></div>
<div class="line"><span class="stringliteral">    }</span></div>
<div class="line"><span class="stringliteral">  })&quot;);</span></div>
<div class="line"><span class="stringliteral">  </span><span class="keyword">auto</span> data = json[<span class="stringliteral">&quot;my_value&quot;</span>].<a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html#a4383138b64646d372ab3990e38e2fc62" title="Returns value of *this converted to T.">As</a>&lt;MyKeyValue&gt;();</div>
<div class="line">  EXPECT_EQ(data.field1, <span class="stringliteral">&quot;one&quot;</span>);</div>
<div class="line">  EXPECT_EQ(data.field2, 1);</div>
<div class="line">}</div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
</div><!-- fragment --><p>You can write a single parser for all formats, just make it a template:</p>
<div class="fragment"></div><!-- fragment --><h2><a class="anchor" id="autotoc_md103"></a>
Inline helpers formats::*::Make*</h2>
<p>To build objects of trivial types some of the formats provide inline helpers, like <a class="el" href="../../d3/dcb/group__userver__formats.html#gafc1e568ca1efc4014483f1bf319e105d">formats::json::MakeArray()</a>, <a class="el" href="../../d3/dcb/group__userver__formats.html#ga9fbc3907a2068f250572de539e6cf6de">formats::json::MakeObject()</a>:</p>
<div class="fragment"></div><!-- fragment --><p> Or <a class="el" href="../../dd/dee/namespaceformats_1_1bson.html#a63db58ec47961e5e12ca50d7f4d58636" title="Constructs a Document from provided key-value pairs.">formats::bson::MakeDoc()</a>, <a class="el" href="../../dd/dee/namespaceformats_1_1bson.html#a9037c8402aa532f2c93c89d1e9f573ab" title="Constructs an array Value from provided element list.">formats::bson::MakeArray()</a>:</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> doc = <a class="code" href="../../dd/dee/namespaceformats_1_1bson.html#a63db58ec47961e5e12ca50d7f4d58636" title="Constructs a Document from provided key-value pairs.">formats::bson::MakeDoc</a>(</div>
<div class="line">      <span class="stringliteral">&quot;key_a&quot;</span>, <a class="code" href="../../dd/dee/namespaceformats_1_1bson.html#a9037c8402aa532f2c93c89d1e9f573ab" title="Constructs an array Value from provided element list.">formats::bson::MakeArray</a>(0, 1, 2),           <span class="comment">//</span></div>
<div class="line">      <span class="stringliteral">&quot;key_d&quot;</span>, <a class="code" href="../../dd/dee/namespaceformats_1_1bson.html#a63db58ec47961e5e12ca50d7f4d58636" title="Constructs a Document from provided key-value pairs.">formats::bson::MakeDoc</a>(<span class="stringliteral">&quot;one&quot;</span>, 1, <span class="stringliteral">&quot;two&quot;</span>, 2),  <span class="comment">//</span></div>
<div class="line">      <span class="stringliteral">&quot;key_n&quot;</span>, <span class="keyword">nullptr</span>                                      <span class="comment">//</span></div>
<div class="line">  );</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> umap = doc[<span class="stringliteral">&quot;key_d&quot;</span>].As&lt;std::unordered_map&lt;std::string, int&gt;&gt;();</div>
<div class="line">  EXPECT_EQ(1, umap[<span class="stringliteral">&quot;one&quot;</span>]);</div>
<div class="line">  EXPECT_EQ(2, umap[<span class="stringliteral">&quot;two&quot;</span>]);</div>
</div><!-- fragment --><p> Those inline helper functions usually work slightly faster than <code>formats::*::ValueBuilder</code>. However, if you need a <code>std::string</code> with JSON the fastest way would be to use the <a class="el" href="../../db/dd7/md_en_userver_formats.html#formats_streaming_serialization">Streaming Serialization</a>. Inline helpers could not be customized for used provided types, unlike other format building types. Inline helpers could produce broken value on bad input because they skip some of the checks, for example a key uniqueness check.</p>
<h2><a class="anchor" id="autotoc_md104"></a>
formats::*::ValueBuilder</h2>
<p>Classes <code><a class="el" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a></code>, <code><a class="el" href="../../de/d70/classformats_1_1bson_1_1ValueBuilder.html" title="Builder for BSON.">formats::bson::ValueBuilder</a></code> and <code><a class="el" href="../../d9/de3/classformats_1_1yaml_1_1ValueBuilder.html" title="Builder for YAML.">formats::yaml::ValueBuilder</a></code> are designed for building objects of a given format.</p>
<p>Usage Example:</p>
<div class="fragment"><div class="line">  <span class="comment">// #include &lt;userver/formats/json.hpp&gt;</span></div>
<div class="line">  <a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a> builder;</div>
<div class="line">  builder[<span class="stringliteral">&quot;key1&quot;</span>] = 1;</div>
<div class="line">  builder[<span class="stringliteral">&quot;key2&quot;</span>][<span class="stringliteral">&quot;key3&quot;</span>] = <span class="stringliteral">&quot;val&quot;</span>;</div>
<div class="line">  <a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> json = builder.<a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html#a078ae0edbffa37a654914629000680ad" title="Take out the resulting Value object. After calling this method the object is in unspecified (but vali...">ExtractValue</a>();</div>
<div class="line"> </div>
<div class="line">  ASSERT_EQ(json[<span class="stringliteral">&quot;key1&quot;</span>].As&lt;int&gt;(), 1);</div>
<div class="line">  ASSERT_EQ(json[<span class="stringliteral">&quot;key2&quot;</span>][<span class="stringliteral">&quot;key3&quot;</span>].As&lt;std::string&gt;(), <span class="stringliteral">&quot;val&quot;</span>);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md105"></a>
Customization of formats::*::ValueBuilder</h2>
<p>In order for <code>formats::*::ValueBuilder</code> to be able to represent a C++ type in the specified format, you should write a special function <code>Serialize</code> for that C++ type. <code>Serialize</code> should be located in the namespace of the type or may be located in the <code><a class="el" href="../../d4/d6e/namespaceformats_1_1common.html" title="Common utilities for all the formats.">formats::common</a></code> namespace if the type comes from third-party library that you have no control of:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyKeyValue {</div>
<div class="line">  std::string field1;</div>
<div class="line">  <span class="keywordtype">int</span> field2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The function must be declared in the namespace of your type</span></div>
<div class="line"><a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> <a class="code" href="../../da/d81/namespacedecimal64.html#a4b4e3949d5a30d3fb74593264c484a6f" title="Serializes the Decimal to string.">Serialize</a>(<span class="keyword">const</span> MyKeyValue&amp; data,</div>
<div class="line">                               <a class="code" href="../../d7/d48/structformats_1_1serialize_1_1To.html">formats::serialize::To&lt;formats::json::Value&gt;</a>) {</div>
<div class="line">  <a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a> builder;</div>
<div class="line">  builder[<span class="stringliteral">&quot;field1&quot;</span>] = data.field1;</div>
<div class="line">  builder[<span class="stringliteral">&quot;field2&quot;</span>] = data.field2;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> builder.<a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html#a078ae0edbffa37a654914629000680ad" title="Take out the resulting Value object. After calling this method the object is in unspecified (but vali...">ExtractValue</a>();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(JsonValueBuilder, ExampleCustomization) {</div>
<div class="line">  MyKeyValue <span class="keywordtype">object</span> = {<span class="stringliteral">&quot;val&quot;</span>, 1};</div>
<div class="line">  <a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a> builder;</div>
<div class="line">  builder[<span class="stringliteral">&quot;example&quot;</span>] = object;</div>
<div class="line">  <span class="keyword">auto</span> json = builder.<a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html#a078ae0edbffa37a654914629000680ad" title="Take out the resulting Value object. After calling this method the object is in unspecified (but vali...">ExtractValue</a>();</div>
<div class="line">  ASSERT_EQ(json[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field1&quot;</span>].As&lt;std::string&gt;(), <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line">  ASSERT_EQ(json[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field2&quot;</span>].As&lt;int&gt;(), 1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
<div class="line"> </div>
</div><!-- fragment --><p> You can write a single serializer for all formats, for make it a template:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d5/db8/json_8hpp.html" title="Include-all header for JSON support.">userver/formats/json.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="../../d5/d95/yaml_8hpp.html" title="Include-all header for YAML support.">userver/formats/yaml.hpp</a>&gt;</span></div>
<div class="line"> </div>
<div class="line">USERVER_NAMESPACE_BEGIN</div>
<div class="line"> </div>
<div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyKeyValue {</div>
<div class="line">  std::string field1;</div>
<div class="line">  <span class="keywordtype">int</span> field2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The function must be declared in the namespace of your type</span></div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Value&gt;</div>
<div class="line"><a class="code" href="../../de/d91/classformats_1_1json_1_1Value.html" title="Non-mutable JSON value representation.">formats::json::Value</a> <a class="code" href="../../da/d81/namespacedecimal64.html#a4b4e3949d5a30d3fb74593264c484a6f" title="Serializes the Decimal to string.">Serialize</a>(<span class="keyword">const</span> MyKeyValue&amp; data,</div>
<div class="line">                               <a class="code" href="../../d7/d48/structformats_1_1serialize_1_1To.html">formats::serialize::To&lt;Value&gt;</a>) {</div>
<div class="line">  <span class="keyword">typename</span> Value::Builder builder;</div>
<div class="line">  builder[<span class="stringliteral">&quot;field1&quot;</span>] = data.field1;</div>
<div class="line">  builder[<span class="stringliteral">&quot;field2&quot;</span>] = data.field2;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">return</span> builder.ExtractValue();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(CommonFormats, <a class="code" href="../../da/d81/namespacedecimal64.html#a4b4e3949d5a30d3fb74593264c484a6f" title="Serializes the Decimal to string.">Serialize</a>) {</div>
<div class="line">  MyKeyValue obj = {<span class="stringliteral">&quot;val&quot;</span>, 1};</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// json</span></div>
<div class="line">  <a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a> builderJson;</div>
<div class="line">  builderJson[<span class="stringliteral">&quot;example&quot;</span>] = obj;</div>
<div class="line">  <span class="keyword">auto</span> json = builderJson.<a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html#a078ae0edbffa37a654914629000680ad" title="Take out the resulting Value object. After calling this method the object is in unspecified (but vali...">ExtractValue</a>();</div>
<div class="line">  EXPECT_EQ(json[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field1&quot;</span>].As&lt;std::string&gt;(), <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line">  EXPECT_EQ(json[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field2&quot;</span>].As&lt;int&gt;(), 1);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// yaml</span></div>
<div class="line">  <a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a> builderYaml;</div>
<div class="line">  builderYaml[<span class="stringliteral">&quot;example&quot;</span>] = obj;</div>
<div class="line">  <span class="keyword">auto</span> yaml = builderYaml.<a class="code" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html#a078ae0edbffa37a654914629000680ad" title="Take out the resulting Value object. After calling this method the object is in unspecified (but vali...">ExtractValue</a>();</div>
<div class="line">  EXPECT_EQ(yaml[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field1&quot;</span>].As&lt;std::string&gt;(), <span class="stringliteral">&quot;val&quot;</span>);</div>
<div class="line">  EXPECT_EQ(yaml[<span class="stringliteral">&quot;example&quot;</span>][<span class="stringliteral">&quot;field2&quot;</span>].As&lt;int&gt;(), 1);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
</div><!-- fragment --><p><a class="anchor" id="formats_streaming_serialization"></a></p>
<h2><a class="anchor" id="autotoc_md106"></a>
Streaming Serialization</h2>
<p>For runtime-critical code, it is possible to use streaming serializers. They allow you to serialize several times faster than <code><a class="el" href="../../d2/daa/classformats_1_1json_1_1ValueBuilder.html" title="Builder for JSON.">formats::json::ValueBuilder</a></code>, but should be used carefully because may produce broken format.</p>
<p>At the moment, <b>stream serialization is implemented only for JSON</b> via the <code><a class="el" href="../../da/d55/classformats_1_1json_1_1StringBuilder.html" title="SAX like builder of JSON string. Use with extreme caution and only in performance critical part of yo...">formats::json::StringBuilder</a></code>.</p>
<p>In order for stream serialization to work with your data type, you need to define the <code>WriteToStream</code> function in the namespace of your type:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>my_namespace {</div>
<div class="line"> </div>
<div class="line"><span class="keyword">struct </span>MyKeyValue {</div>
<div class="line">  std::string field1;</div>
<div class="line">  <span class="keywordtype">int</span> field2;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// The function must be declared in the namespace of your type</span></div>
<div class="line"><span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="../../da/d81/namespacedecimal64.html#aefab7afd1e43337052854ff312601e0f" title="Writes the Decimal to stream.">WriteToStream</a>(<span class="keyword">const</span> MyKeyValue&amp; data,</div>
<div class="line">                          <a class="code" href="../../da/d55/classformats_1_1json_1_1StringBuilder.html" title="SAX like builder of JSON string. Use with extreme caution and only in performance critical part of yo...">formats::json::StringBuilder</a>&amp; sw) {</div>
<div class="line">  <span class="comment">// A class that adds &#39;{&#39; in the constructor and &#39;}&#39; in the destructor to JSON</span></div>
<div class="line">  <a class="code" href="../../dc/d9e/classformats_1_1json_1_1StringBuilder_1_1ObjectGuard.html">formats::json::StringBuilder::ObjectGuard</a> guard{sw};</div>
<div class="line"> </div>
<div class="line">  sw.<a class="code" href="../../da/d55/classformats_1_1json_1_1StringBuilder.html#a7057fbfd7f40ad44d80dd4c48d351eeb" title="ONLY for objects/dicts: write key.">Key</a>(<span class="stringliteral">&quot;field1&quot;</span>);</div>
<div class="line">  <span class="comment">// Use the WriteToStream functions for values, don&#39;t work with StringBuilder</span></div>
<div class="line">  <span class="comment">// directly</span></div>
<div class="line">  <a class="code" href="../../da/d81/namespacedecimal64.html#aefab7afd1e43337052854ff312601e0f" title="Writes the Decimal to stream.">WriteToStream</a>(data.field1, sw);</div>
<div class="line"> </div>
<div class="line">  sw.<a class="code" href="../../da/d55/classformats_1_1json_1_1StringBuilder.html#a7057fbfd7f40ad44d80dd4c48d351eeb" title="ONLY for objects/dicts: write key.">Key</a>(<span class="stringliteral">&quot;field2&quot;</span>);</div>
<div class="line">  <a class="code" href="../../da/d81/namespacedecimal64.html#aefab7afd1e43337052854ff312601e0f" title="Writes the Decimal to stream.">WriteToStream</a>(data.field2, sw);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">TEST(JsonStringBuilder, ExampleUsage) {</div>
<div class="line">  StringBuilder sb;</div>
<div class="line">  MyKeyValue data = {<span class="stringliteral">&quot;one&quot;</span>, 1};</div>
<div class="line">  <a class="code" href="../../da/d81/namespacedecimal64.html#aefab7afd1e43337052854ff312601e0f" title="Writes the Decimal to stream.">WriteToStream</a>(data, sb);</div>
<div class="line">  ASSERT_EQ(sb.GetString(), <span class="stringliteral">&quot;{\&quot;field1\&quot;:\&quot;one\&quot;,\&quot;field2\&quot;:1}&quot;</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">}  <span class="comment">// namespace my_namespace</span></div>
</div><!-- fragment --><p>Note that you may get <b>invalid</b> JSON, since:</p><ul>
<li>methods <code>format::json methods::StringBuilder::Key</code> <b>does not</b> check the uniqueness of keys</li>
<li><code>StringBuilder</code> itself does not put curly brackets, you need to use <code><a class="el" href="../../dc/d9e/classformats_1_1json_1_1StringBuilder_1_1ObjectGuard.html">formats::json::StringBuilder::ObjectGuard</a></code></li>
<li><code>StringBuilder</code> itself does not put square brackets, you need to use <code><a class="el" href="../../d2/da7/classformats_1_1json_1_1StringBuilder_1_1ArrayGuard.html">formats::json::StringBuilder::ArrayGuard</a></code></li>
<li>You can write any nonsense in JSON using <code>StringBuilder</code> methods</li>
<li>etc.</li>
</ul>
<p>Test your serializers! </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">⚒ Редактировать страницу</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "а":"a", "б":"b", "в":"v", "г":"g", "д":"d", "е":"e", "ё":"jo", "ж":"zh",
    "з":"z", "и":"i", "й":"jj", "к":"k", "л":"l", "м":"m", "н":"n", "о":"o",
    "п":"p", "р":"r", "с":"s", "т":"t", "у":"u", "ф":"f", "х":"x", "ц":"c",
    "ч":"ch", "ш":"sh", "щ":"shh", "ъ":"\'", "ы":"y", "ь":"\'", "э":"je",
    "ю":"ju", "я":"ja"
};
const DOXYGEN_DIAMOND_STRING = '◆\u00A0' // ◆&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '•&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">🔗</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
