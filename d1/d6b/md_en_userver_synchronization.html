<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link rel="icon" href="../../favicon.svg">
<title>userver: Synchronization Primitives</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<link rel="stylesheet" href="../../doxygen-like.css">
<script src="../../highlight.pack.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" style="width: 100%;">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><a id='logo-anchor' href="../../index.html"><img alt="Logo" src="../../logo.svg"/></a></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname"><a class="titlelink" href="../../index.html">userver
   </a>
   </div>
   <div id="projectbrief"><a class="titlelink" href="../../index.html">C++ Async Framework (beta)</a></div>
  </td>
  <td style="float: right; padding-right: 40px; padding-top: 15px;">
    <a href="https://github.com/userver-framework/userver" rel="noopener" target="_blank" class="titlelink">
      <img src="../../github_logo.svg" alt="Github"/>
    </a>
    &nbsp;
    <a href="https://t.me/+i3k5A6V0oFgwNmYy" rel="noopener" id='telegram_channel' target="_blank" class="titlelink">
      <img src="../../telegram_logo.svg" alt="Telegram"/>
    </a>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Synchronization Primitives </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page describes the synchronization mechanisms that are available in userver, their advantages and weaknesses. It is assumed that the developer is aware of concurrent programming and concepts like "race", "critical section", "mutex".</p>
<h1><a class="anchor" id="autotoc_md206"></a>
Constraint</h1>
<p>‚ö†Ô∏èüêô‚ùó Use of the C++ standard library and libc synchronization primitives in coroutines <b>is forbidden</b>.</p>
<h1><a class="anchor" id="autotoc_md207"></a>
Synchronization mechanisms and primitives</h1>
<p>This section describes the major available synchronization mechanisms with use cases. All the primitives are listed at the <a class="el" href="../../dc/db7/group__userver__concurrency.html">Concurrency</a> API Group.</p>
<blockquote class="doxtable">
<p>There is no "faster" synchronization mechanism. Different primitives are suitable for different situations. For some load profile primitive A could be 1000 times faster than primitive B. For another - exactly the opposite. Before choosing a primitive, determinate the load profile (how often does reading and writing occur, how many concurrent writers/readers are there etc). For a practical assessment of the effectiveness of a particular tool for your case, use <a href="https://github.com/google/benchmark">google benchmark</a> and <a href="https://wiki.yandex-team.ru/taxi/backend/userver/load/">stress testing</a>. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md208"></a>
engine::TaskWithResult</h2>
<p>For parallel independent calculations the simplest, and most reliable way to transmit data is through the result of the <a class="el" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult</a> execution.</p>
<div class="fragment"><div class="line">  std::vector&lt;engine::TaskWithResult&lt;int&gt;&gt; tasks;</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> value : container) {</div>
<div class="line">    <span class="comment">// Creating tasks that will be executed in parallel</span></div>
<div class="line">    tasks.push_back(<a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(<span class="stringliteral">&quot;some_task&quot;</span>, [value = std::move(value)] {</div>
<div class="line">      <a class="code" href="../../dc/d3f/namespaceengine.html#a19462f750672c6fa7f5f690c2575b9f6">engine::InterruptibleSleepFor</a>(std::chrono::milliseconds(100));</div>
<div class="line">      <span class="keywordflow">return</span> value;</div>
<div class="line">    }));</div>
<div class="line">  }</div>
<div class="line">  <span class="comment">// we wait for the completion of tasks and get the results</span></div>
<div class="line">  std::vector&lt;int&gt; results;</div>
<div class="line">  results.reserve(tasks.size());</div>
<div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; task : tasks) {</div>
<div class="line">    <span class="comment">// If the task completed with an exception,</span></div>
<div class="line">    <span class="comment">// then Get () will throw an exception</span></div>
<div class="line">    results.push_back(task.Get());</div>
<div class="line">  }</div>
</div><!-- fragment --><p> A less convenient and more complicated way to solve the same problem is to create a data structure shared between tasks, where the tasks themselves will record the result. This requires protecting the data through atomic variables or <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a>, as well as passing this data structure to the subtasks. In this case, <a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a> may be useful (see below).</p>
<p>Note that when programming tasks, you need to take into account the lifetime of objects. If you pass a closure to a task with a reference to a variable, then you must ensure that the lifetime of the task is strictly less than the lifetime of the variable. This must also be guaranteed for the case of throwing an exception from any function used. If this cannot be guaranteed, then either pass the data to the closure via shared_ptr, or pass it over the copy.</p>
<h2><a class="anchor" id="autotoc_md209"></a>
engine::Future</h2>
<p>Sometimes calculations could not decomposed easily and a single <a class="el" href="../../d8/d7c/classengine_1_1Task.html" title="Asynchronous task.">engine::Task</a> should return many results. At the same time, it is not efficient to collect them into one structure and return them at one (the results are used as inputs for several tasks, etc.). For such cases, you can use the <a class="el" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise</a> and <a class="el" href="../../d8/d67/classengine_1_1Future.html" title="std::future replacement for asynchronous tasks that works in pair with engine::Promise">engine::Future</a>. They provide a synchronized channel for transmitting the value between tasks. The interface and contracts of these classes are as close as possible to similar types from the standard library. The main differences are related to the support for the cancellation mechanism.</p>
<div class="fragment"><div class="line">  <a class="code" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise&lt;int&gt;</a> int_promise;</div>
<div class="line">  <a class="code" href="../../d9/d2e/classengine_1_1Promise.html" title="std::promise replacement for asynchronous tasks that works in pair with engine::Future">engine::Promise&lt;std::string&gt;</a> string_promise;</div>
<div class="line">  <span class="keyword">auto</span> deadline = GetDeadline();</div>
<div class="line"> </div>
<div class="line">  constexpr <span class="keyword">auto</span> kBadValue = -1;</div>
<div class="line">  constexpr <span class="keyword">auto</span> kFallbackString = <span class="stringliteral">&quot;Bad string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  constexpr <span class="keyword">auto</span> kTestValue = 777;</div>
<div class="line">  constexpr <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;Test string value&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> int_future = int_promise.<a class="code" href="../../d9/d2e/classengine_1_1Promise.html#a70eab6f2622012a68684aa1a05c0fbdb">get_future</a>();</div>
<div class="line">  <span class="keyword">auto</span> string_future = string_promise.<a class="code" href="../../d9/d2e/classengine_1_1Promise.html#a70eab6f2622012a68684aa1a05c0fbdb">get_future</a>();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> calc_task =</div>
<div class="line">      <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(<span class="stringliteral">&quot;calc&quot;</span>, [int_promise = std::move(int_promise),</div>
<div class="line">                            string_promise = std::move(string_promise),</div>
<div class="line">                            kTestValue]() <span class="keyword">mutable</span> {</div>
<div class="line">        <span class="comment">// Emulating long calculation of x and s...</span></div>
<div class="line">        <a class="code" href="../../dc/d3f/namespaceengine.html#a3f0a331825dbd69a272a606b7d5006ed" title="Suspends execution for at least a specified amount of time.">engine::SleepFor</a>(std::chrono::milliseconds(100));</div>
<div class="line">        int_promise.<a class="code" href="../../d9/d2e/classengine_1_1Promise.html#afe9369eedca9868c41f689ff15799b98">set_value</a>(kTestValue);</div>
<div class="line"> </div>
<div class="line">        <a class="code" href="../../dc/d3f/namespaceengine.html#a3f0a331825dbd69a272a606b7d5006ed" title="Suspends execution for at least a specified amount of time.">engine::SleepFor</a>(std::chrono::milliseconds(100));</div>
<div class="line">        string_promise.<a class="code" href="../../d9/d2e/classengine_1_1Promise.html#afe9369eedca9868c41f689ff15799b98">set_value</a>(kTestString);</div>
<div class="line">        <span class="comment">// Other calculations.</span></div>
<div class="line">      });</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> int_consumer = <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(</div>
<div class="line">      <span class="stringliteral">&quot;int_consumer&quot;</span>,</div>
<div class="line">      [deadline, int_future = std::move(int_future), kTestValue]() <span class="keyword">mutable</span> {</div>
<div class="line">        <span class="keyword">auto</span> status = int_future.wait_until(deadline);</div>
<div class="line">        <span class="keyword">auto</span> x = kBadValue;</div>
<div class="line">        <span class="keywordflow">switch</span> (status) {</div>
<div class="line">          <span class="keywordflow">case</span> <a class="code" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a25d5606fe07425ea73f245c48612c039" title="the future is ready">engine::FutureStatus::kReady</a>:</div>
<div class="line">            x = int_future.get();</div>
<div class="line">            ASSERT_EQ(x, kTestValue);</div>
<div class="line">            <span class="comment">// ...</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">case</span> <a class="code" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a7f27861ff1d3f550c6aa77150d7edabd" title="the wait operation timed out">engine::FutureStatus::kTimeout</a>:</div>
<div class="line">            <span class="comment">// Timeout Handling</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">          <span class="keywordflow">case</span> <a class="code" href="../../dc/d3f/namespaceengine.html#aff83cd4a0be2c8f190011be96976f3c2a971493a769ad0aed23946733ede4a8f1" title="the wait operation was interrupted by task cancellation">engine::FutureStatus::kCancelled</a>:</div>
<div class="line">            <span class="comment">// Handling cancellation of calculations</span></div>
<div class="line">            <span class="comment">// (example, return to queue)</span></div>
<div class="line">            <span class="keywordflow">break</span>;</div>
<div class="line">        }</div>
<div class="line">      });</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> string_consumer = <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(</div>
<div class="line">      <span class="stringliteral">&quot;string_consumer&quot;</span>,</div>
<div class="line">      [string_future = std::move(string_future), kTestString]() <span class="keyword">mutable</span> {</div>
<div class="line">        std::string s;</div>
<div class="line">        <span class="keywordflow">try</span> {</div>
<div class="line">          s = string_future.get();</div>
<div class="line">          ASSERT_EQ(s, kTestString);</div>
<div class="line">        } <span class="keywordflow">catch</span> (<span class="keyword">const</span> std::exception&amp; ex) {</div>
<div class="line">          <span class="comment">// Exception Handling</span></div>
<div class="line">          s = kFallbackString;</div>
<div class="line">        }</div>
<div class="line">        <span class="comment">// ...</span></div>
<div class="line">      });</div>
<div class="line"> </div>
<div class="line">  calc_task.Get();</div>
<div class="line">  int_consumer.Get();</div>
<div class="line">  string_consumer.Get();</div>
</div><!-- fragment --><p> In this case, the main mechanism for transmitting data remains the return of values from TaskWithResult.</p>
<h2><a class="anchor" id="autotoc_md210"></a>
concurrent::MpscQueue</h2>
<p>For long-living tasks it is convenient to use message queues. In <code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a></code>, writers (one or more) can write data to the queue, and on the other hand, a reader can read what is written. The order of objects written by different writers is not defined.</p>
<div class="fragment"><div class="line">  <span class="keyword">static</span> constexpr std::chrono::milliseconds kTimeout{10};</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> queue = <a class="code" href="../../d0/d92/classconcurrent_1_1MpscQueue.html#a9e0d91c074a927a75ef54136c2b058ce" title="Create a new queue.">concurrent::MpscQueue&lt;int&gt;::Create</a>();</div>
<div class="line">  <span class="keyword">auto</span> producer = queue-&gt;GetProducer();</div>
<div class="line">  <span class="keyword">auto</span> consumer = queue-&gt;GetConsumer();</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> producer_task = <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(<span class="stringliteral">&quot;producer&quot;</span>, [&amp;] {</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">    <span class="keywordflow">if</span> (!producer.Push(1, <a class="code" href="../../de/d6a/classengine_1_1Deadline.html#a66be0304dfd971e3636a8b9c083cf47c" title="Converts duration to a Deadline.">engine::Deadline::FromDuration</a>(kTimeout))) {</div>
<div class="line">      <span class="comment">// The reader is dead</span></div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> consumer_task = <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(<span class="stringliteral">&quot;consumer&quot;</span>, [&amp;] {</div>
<div class="line">    <span class="keywordflow">for</span> (;;) {</div>
<div class="line">      <span class="comment">// ...</span></div>
<div class="line">      <span class="keywordtype">int</span> item;</div>
<div class="line">      <span class="keywordflow">if</span> (consumer.Pop(item, <a class="code" href="../../de/d6a/classengine_1_1Deadline.html#a66be0304dfd971e3636a8b9c083cf47c" title="Converts duration to a Deadline.">engine::Deadline::FromDuration</a>(kTimeout))) {</div>
<div class="line">        <span class="comment">// processing the queue element</span></div>
<div class="line">        ASSERT_EQ(item, 1);</div>
<div class="line">      } <span class="keywordflow">else</span> {</div>
<div class="line">        <span class="comment">// the queue is empty and there are no more live producers</span></div>
<div class="line">        return;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  });</div>
<div class="line">  producer_task.Get();</div>
<div class="line">  consumer_task.Get();</div>
</div><!-- fragment --><p> If the queue is supposed to pass data types <code>T</code> with a non-trivial destructor, then you need to use the queue <code><a class="el" href="../../d0/d92/classconcurrent_1_1MpscQueue.html">concurrent::MpscQueue</a>&lt;std::unique_ptr&lt;T&gt;&gt;</code>. If the queue with unread data is destroyed, all unprocessed items will be released correctly.</p>
<p>Use this class by default. However, if you really need higher performance use NonFifo queues:</p>
<ul>
<li><code>concurrent::NonFifoMpmcQueue</code></li>
<li><code>concurrent::NonFifoMpscQueue</code></li>
<li><code>concurrent::NonFifoSpmcQueue</code></li>
<li><code>concurrent::NonFifoSpscQueue</code></li>
</ul>
<p>NonFifo queues do not guarantee FIFO order of the elements of the queue and thereby have higher performance.</p>
<h2><a class="anchor" id="autotoc_md211"></a>
std::atomic</h2>
<p>If you need to access small trivial types (<code>int</code>, <code>long</code>, <code>std::size_t</code>, <code>bool</code>) in shared memory from different tasks, then atomic variables may help. Beware, for complex types compiler generates code with implicit use of synchronization primitives forbidden in userver. If you are using <code>std::atomic</code> with a non-trivial or type parameters with big size, then be sure to write a test to check that accessing this variable does not impose a mutex.</p>
<p>It is not recommended to use non-default memory_orders (for example, acquire/release), because their use is fraught with great difficulties. In such code, it is very easy to get bug that will be extremely difficult to detect. Therefore, it is better to use a simpler and more reliable default, the std::memory_order_seq_cst.</p>
<h2><a class="anchor" id="autotoc_md212"></a>
engine::Mutex</h2>
<p>A classic mutex. It allows you to work with standard <code>std::unique_lock</code> and <code>std::lock_guard</code>.</p>
<div class="fragment"><div class="line">  <a class="code" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a> mutex;</div>
<div class="line">  constexpr <span class="keyword">auto</span> kTestData = <span class="stringliteral">&quot;Test Data&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    std::lock_guard&lt;engine::Mutex&gt; lock(mutex);</div>
<div class="line">    <span class="comment">// accessing data under a mutex</span></div>
<div class="line">    <span class="keyword">auto</span> x = kTestData;</div>
<div class="line">    ASSERT_EQ(kTestData, x);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Prefer using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code> instead of an <code><a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a></code>.</p>
<h2><a class="anchor" id="autotoc_md213"></a>
engine::SharedMutex</h2>
<p>A mutex that has readers and writers. It allows you to work with standard <code>std::unique_lock</code>,<code>std::lock_guard</code> and <code>std::shared_lock</code>.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  constexpr <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;123&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <a class="code" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks">engine::SharedMutex</a> mutex;</div>
<div class="line">  std::string data;</div>
<div class="line">  {</div>
<div class="line">    std::lock_guard&lt;engine::SharedMutex&gt; lock(mutex);</div>
<div class="line">    <span class="comment">// accessing the data under the mutex for writing</span></div>
<div class="line">    data = kTestString;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    std::shared_lock&lt;engine::SharedMutex&gt; lock(mutex);</div>
<div class="line">    <span class="comment">// accessing the data under the mutex for reading,</span></div>
<div class="line">    <span class="comment">// data cannot be changed</span></div>
<div class="line">    <span class="keyword">auto</span> x = data;</div>
<div class="line">    ASSERT_EQ(x, kTestString);</div>
<div class="line">  }</div>
</div><!-- fragment --><p> <a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks">engine::SharedMutex</a> is a much more complex and heavier synchronization primitive than a regular <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a>. The fact of the existence of readers and writers does not mean that <a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks">engine::SharedMutex</a> will be faster than an <a class="el" href="../../d0/da4/classengine_1_1Mutex.html" title="std::mutex replacement for asynchronous tasks">engine::Mutex</a>. For example, if the critical section is small (2-3 integer variables), then the SharedMutex overhead can outweigh all the gain from concurrent reads. Therefore, you should not mindlessly use SharedMutex without benchmarks. Also, the "frequent reads, rare writes" scenario in most cases is solved much more efficiently through RCU - <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code>.</p>
<p>Read locking of the SharedMutex is slower than reading an <code>RCU</code>. However, SharedMutex does not require copying data on modification, unlike <code>RCU</code>. Therefore, in the case of expensive data copies that are protected by a critical section, it makes sense to use SharedMutex instead of <code>RCU</code>. If the cost of copying is low, then it is usually more profitable to use <code>RCU</code>.</p>
<p>To work with a mutex, we recommend using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code>. This reduces the risk of taking a mutex in the wrong mode, the wrong mutex, and so on.</p>
<h2><a class="anchor" id="autotoc_md214"></a>
rcu::Variable</h2>
<p>A synchronization primitive with readers and writers that allows readers to work with the old version of the data while the writer fills in the new version of the data. Multiple versions of the protected data can exist at any given time. The old version is deleted when the RCU realizes that no one else is working with it. This can happen when writing a new version is finished if there are no active readers. If at least one reader holds an old version of the data, it will not be deleted.</p>
<p>RCU should be the "default" synchronization primitive for the case of frequent readers and rare writers. Very poorly suited for frequent updates, because a copy of the data is created on update.</p>
<div class="fragment"><div class="line"> </div>
<div class="line">  constexpr <span class="keywordtype">int</span> kOldValue = 1;</div>
<div class="line">  constexpr <span class="keyword">auto</span> kOldString = <span class="stringliteral">&quot;Old string&quot;</span>;</div>
<div class="line">  constexpr <span class="keywordtype">int</span> kNewValue = 2;</div>
<div class="line">  constexpr <span class="keyword">auto</span> kNewString = <span class="stringliteral">&quot;New string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Data {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    std::string s;</div>
<div class="line">  };</div>
<div class="line">  <a class="code" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable&lt;Data&gt;</a> data = Data{kOldValue, kOldString};</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> ro_ptr = data.<a class="code" href="../../d8/d5a/classrcu_1_1Variable.html#a72d80b8e5c6793877238a42f75a38583" title="Obtain a smart pointer which can be used to read the current value.">Read</a>();</div>
<div class="line">    <span class="comment">// We can use ro_ptr to access data.</span></div>
<div class="line">    <span class="comment">// At this time, neither the writer nor the other readers are not blocked</span></div>
<div class="line">    <span class="comment">// =&gt; you can hold a smart pointer without fear of blocking other users</span></div>
<div class="line">    ASSERT_EQ(ro_ptr-&gt;x, kOldValue);</div>
<div class="line">    ASSERT_EQ(ro_ptr-&gt;s, kOldString);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="keyword">auto</span> ptr = data.<a class="code" href="../../d8/d5a/classrcu_1_1Variable.html#a3ba4501a797d0a8608e60cfcca6548b7">StartWrite</a>();</div>
<div class="line">    <span class="comment">// ptr stores a copy of the latest version of the data, now we can prepare</span></div>
<div class="line">    <span class="comment">// a new version Readers continue to access the old version of the data</span></div>
<div class="line">    <span class="comment">// via .Read()</span></div>
<div class="line">    ptr-&gt;x = kNewValue;</div>
<div class="line">    ptr-&gt;s = kNewString;</div>
<div class="line">    <span class="comment">// After Commit(), the next reader in Read() gets the version of the data</span></div>
<div class="line">    <span class="comment">// we just wrote. Old readers who did Read() before Commit() continue to</span></div>
<div class="line">    <span class="comment">// work with the old version of the data.</span></div>
<div class="line">    ptr.Commit();</div>
<div class="line">  }</div>
</div><!-- fragment --><p> Comparison with SharedMutex is described in the <code><a class="el" href="../../d6/d70/classengine_1_1SharedMutex.html" title="std::shared_mutex replacement for asynchronous tasks">engine::SharedMutex</a></code> section of this page.</p>
<h2><a class="anchor" id="autotoc_md215"></a>
rcu::RcuMap</h2>
<p><code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> based map. This primitive is used when you need a concurrent dictionary. Well suited for the case of rarely added keys. Poorly suited to the case of a frequently changing set of keys.</p>
<p>Note that RcuMap does not protect the value of the dictionary, it only protects the dictionary itself. If the values are non-atomic types, then they must be protected separately (for example, using <code><a class="el" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable</a></code>).</p>
<div class="fragment"><div class="line">  <span class="keyword">struct </span>Data {</div>
<div class="line">    <span class="comment">// Access to RcuMap content must be synchronized via std::atomic</span></div>
<div class="line">    <span class="comment">// or other synchronization primitives</span></div>
<div class="line">    std::atomic&lt;int&gt; x{0};</div>
<div class="line">    std::atomic&lt;bool&gt; flag{<span class="keyword">false</span>};</div>
<div class="line">  };</div>
<div class="line">  <a class="code" href="../../d0/d1f/classrcu_1_1RcuMap.html" title="Map-like structure allowing RCU keyset updates.">rcu::RcuMap&lt;std::string, Data&gt;</a> map;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If the key is not in the dictionary,</span></div>
<div class="line">  <span class="comment">// then a default object will be created</span></div>
<div class="line">  map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;x++;</div>
<div class="line">  map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;flag = <span class="keyword">true</span>;</div>
<div class="line">  ASSERT_EQ(map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;x.load(), 1);</div>
<div class="line">  ASSERT_EQ(map[<span class="stringliteral">&quot;123&quot;</span>]-&gt;flag.load(), <span class="keyword">false</span>);</div>
<div class="line">  ASSERT_EQ(map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;x.load(), 0);</div>
<div class="line">  ASSERT_EQ(map[<span class="stringliteral">&quot;other_data&quot;</span>]-&gt;flag.load(), <span class="keyword">true</span>);</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md216"></a>
concurrent::Variable</h2>
<p>A proxy class that combines user data and a synchronization primitive that protects that data. Its use can greatly reduce the number of bugs associated with incorrect use of the critical section - taking the wrong mutex, forgetting to take the mutex, taking SharedMutex in the wrong mode, etc.</p>
<div class="fragment"><div class="line">  constexpr <span class="keyword">auto</span> kTestString = <span class="stringliteral">&quot;Test string&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">struct </span>Data {</div>
<div class="line">    <span class="keywordtype">int</span> x;</div>
<div class="line">    std::string s;</div>
<div class="line">  };</div>
<div class="line">  <span class="comment">// If you do not specify the 2nd template parameter,</span></div>
<div class="line">  <span class="comment">// then by default Variable is protected by engine::Mutex.</span></div>
<div class="line">  <a class="code" href="../../db/d57/classconcurrent_1_1Variable.html">concurrent::Variable&lt;Data, engine::SharedMutex&gt;</a> data;</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// We get a smart pointer to the data,</span></div>
<div class="line">    <span class="comment">// the smart pointer stores std::lock_guard</span></div>
<div class="line">    <span class="keyword">auto</span> data_ptr = data.Lock();</div>
<div class="line">    data_ptr-&gt;s = kTestString;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  {</div>
<div class="line">    <span class="comment">// We get a smart pointer to the data,</span></div>
<div class="line">    <span class="comment">// the smart pointer stores std::shared_lock</span></div>
<div class="line">    <span class="keyword">auto</span> data_ptr = data.SharedLock();</div>
<div class="line">    <span class="comment">// we can read data, we cannot write</span></div>
<div class="line">    ASSERT_EQ(data_ptr-&gt;s, kTestString);</div>
<div class="line">  }</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md217"></a>
engine::Semaphore</h2>
<p>The semaphore is used to limit the number of users that run inside a critical section. For example, a semaphore can be used to limit the number of simultaneous concurrent attempts to connect to a resource.</p>
<div class="fragment"><div class="line">  constexpr <span class="keyword">auto</span> kMaxSimultaneousLocks = 3;</div>
<div class="line">  <a class="code" href="../../db/d16/classengine_1_1Semaphore.html" title="Class that allows up to max_simultaneous_locks concurrent accesses to the critical section.">engine::Semaphore</a> sema(kMaxSimultaneousLocks);</div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">  {</div>
<div class="line">    std::shared_lock&lt;engine::Semaphore&gt; lock(sema);</div>
<div class="line">    <span class="comment">// There may be no more than 3 users</span></div>
<div class="line">    <span class="comment">// in the critical section at the same time</span></div>
<div class="line">  }</div>
</div><!-- fragment --><p> You don't need to use a semaphore if you need to limit the number of threads that perform CPU-heavy operations. For these purposes, create a separate TaskProcessor and perform other operations on it, it is be cheaper in terms of synchronization.</p>
<p>If you need a counter, but do not need to wait for the counter to change, then you need to use <code>std::atomic</code> instead of a semaphore.</p>
<h2><a class="anchor" id="autotoc_md218"></a>
engine::SingleUseEvent</h2>
<p>A single-producer, single-consumer event without task cancellation support. Must not be awaited or signaled multiple times in the same waiting session.</p>
<p>For multiple producers and cancellation support, use <code><a class="el" href="../../d8/d87/classengine_1_1SingleConsumerEvent.html" title="Event for a single awaiter, multiple signal coroutines.">engine::SingleConsumerEvent</a></code> instead.</p>
<div class="fragment"><div class="line">  <a class="code" href="../../db/d80/classengine_1_1TaskWithResult.html">engine::TaskWithResult&lt;void&gt;</a> sender;</div>
<div class="line">  {</div>
<div class="line">    <a class="code" href="../../dc/dde/classengine_1_1SingleUseEvent.html" title="A single-producer, single-consumer event.">engine::SingleUseEvent</a> event;</div>
<div class="line">    sender = <a class="code" href="../../dc/db7/group__userver__concurrency.html#gac91f56844690ea79c568cb3b43ba98a5">utils::Async</a>(<span class="stringliteral">&quot;sender&quot;</span>, [&amp;event] { <span class="keyword">event</span>.Send(); });</div>
<div class="line">    <span class="keyword">event</span>.WaitNonCancellable();  <span class="comment">// will be woken up by &#39;Send()&#39; above</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// &#39;event&#39; is destroyed here. Note that &#39;Send&#39; might continue executing, but</span></div>
<div class="line">    <span class="comment">// it will still complete safely.</span></div>
<div class="line">  }</div>
</div><!-- fragment --> <h2><a class="anchor" id="autotoc_md219"></a>
utils::SwappingSmart</h2>
<p><b>Don't use</b> <code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code>, use <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> instead. There is a UB in the SwappingSmart behavior.</p>
<p><code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code> protects readers from rare writers, but in the case of very frequent writers, the reader has no guarantee of getting a valid <code>std::shared_ptr</code> (which occasionally fired in production). Also <code><a class="el" href="../../d8/d5a/classrcu_1_1Variable.html" title="Read-Copy-Update variable.">rcu::Variable</a></code> faster than <code><a class="el" href="../../d2/dbd/classutils_1_1SwappingSmart.html">utils::SwappingSmart</a></code> in most cases. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
<a id='page_edit' style="float:left; padding-left: 7pt;" href="#">‚öí –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞–Ω–∏—Ü—É</a>
<address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
<script type="text/javascript">
const LOWER_CASE_TRANSLITTERATION_MAPPING = {
    "–∞":"a", "–±":"b", "–≤":"v", "–≥":"g", "–¥":"d", "–µ":"e", "—ë":"jo", "–∂":"zh",
    "–∑":"z", "–∏":"i", "–π":"jj", "–∫":"k", "–ª":"l", "–º":"m", "–Ω":"n", "–æ":"o",
    "–ø":"p", "—Ä":"r", "—Å":"s", "—Ç":"t", "—É":"u", "—Ñ":"f", "—Ö":"x", "—Ü":"c",
    "—á":"ch", "—à":"sh", "—â":"shh", "—ä":"\'", "—ã":"y", "—å":"\'", "—ç":"je",
    "—é":"ju", "—è":"ja"
};
const DOXYGEN_DIAMOND_STRING = '‚óÜ\u00A0' // ‚óÜ&nbsp;
function make_id(raw_id) {
    return raw_id.toLowerCase().split('').map(function (char) {
        return LOWER_CASE_TRANSLITTERATION_MAPPING[char] || char;
    }).join('').replace(/\W/g, '');
}
const html_escape = function () {
    const p = document.createElement('p');
    return function (text) {
        p.textContent = text;
        return p.innerHTML;
    };
}();
function setup_page_edit() {
    let href = window.location.href;
    const idx = href.indexOf('md_ru_');
    if (idx === -1) {
        $('#page_edit').hide();
        return;
    }
    href = href.substring(idx).split('.html')[0];
    href = href.split('#')[0];
    href = href.replace('md_ru_', 'https://wiki.yandex-team.ru/taxi/backend/');
    href = href.replaceAll('_', '/');
    $('#page_edit').attr("href", href + '/.edit');
}
function draw_toc() {
    let headers = $(':header');
    if (headers.length === 0) {
        return;
    }
    let sidenav_content = '<div id="mySidenav" class="sidenav">';
    sidenav_content += '<h2>Table of contents</h2>';
    headers.each(function() {
        let index = parseInt(this.nodeName.substring(1)) - 1;
        const header = $(this);
        let id = header.attr('id');
        if (!id) {
          id = make_id(header.text())
          header.attr('id', id);
        }
        let header_text = header.text()
        if (header_text.startsWith(DOXYGEN_DIAMOND_STRING)) {
            ++index;
            header_text = header_text.substring(DOXYGEN_DIAMOND_STRING.length);
        }
        sidenav_content += ''
          + '<a href="#' + id + '" style="padding-left: ' + index * 15 + 'px">'
          + '‚Ä¢&nbsp;' + html_escape(header_text)
          + '</a>'
        ;
        header.append(' <a class="hoverlink" href="#' + id + '">üîó</a>')
    });
    sidenav_content += '</div>';
    $(sidenav_content).insertAfter('.header');
}
function highlight_code() {
    if (window.location.href.indexOf("pp_source") !== -1
        || window.location.href.indexOf("cpp-example") !== -1) {
        // Header listing is already nicely highlighted by Doxygen
        return;
    }
    hljs.configure({
        tabReplace: '    ' // 4 spaces
    });
    hljs.registerAliases('py', {languageName: 'python'});
    hljs.registerAliases('sh', {languageName: 'shell'});
    hljs.registerAliases('bash', {languageName: 'shell'});
    hljs.registerAliases('yml', {languageName: 'yaml'});
    hljs.registerAliases('plain', {languageName: 'plaintext'});
    hljs.registerAliases('tskv', {languageName: 'plaintext'});
    $(".fragment").each(function() {
        const node = $(this);
        let data = '';
        let language = '';
        let requires_higlighting = true;
        node.children('div.line').each(function(i) {
            line = $(this).text();
            // Doxygen 1.8.11 workaround to remove line numbers.
            // No line numbers added in Doxygen 1.8.13
            line = line.replace(/^ *\d+\xA0/, '');
            if (i === 0) {
                line = line.trimLeft().replace(/^# /, '');
                if (line === 'autodetect') {
                    return true;
                } else if (hljs.getLanguage(line)) {
                    language = line;
                    return true;
                } else {
                    requires_higlighting = false;
                    return false;
                }
            }
            data += line + '\n';
        });
        if (requires_higlighting === false) {
            return;
        }
        if (language !== '') {
            data = hljs.highlight(language, data).value;
        } else {
            data = hljs.highlightAuto(data).value;
        }
        node.replaceWith('<div class="fragment"><pre>' + data + '</pre></div>');
    });
}
function setup_if_landing() {
    if (document.getElementById('landing_logo_id') === null) {
        return false;
    }
    $('#titlearea').hide();
    const main_nav = $('#main-nav')
    main_nav.addClass('main-nav-landing');
    main_nav.append('<hr>');
    $('.header').hide();
    $('body').css('background-color', 'black');
    $('#page_edit').hide();
    return true;
}
function sticky_menu() {
    const main_nav = $('#main-nav');
    const menu_y_position = 94;
    const search_results_window = $('#MSearchResultsWindow');
    var menu_is_sticky = false;
    const stick = function () {
        if ($(this).scrollTop() > menu_y_position) {
            if (menu_is_sticky) return;
            search_results_window.addClass('stickySearchResults');
            main_nav.addClass('stickyHeader');
            menu_is_sticky = true;
        } else {
            if (!menu_is_sticky) return;
            search_results_window.removeClass('stickySearchResults');
            // 'top' property of the results window is computed by Doxygen JS
            // and it may give bad results if the computation is invoked at the
            // middle of the page.
            //
            // Hiding the window. Doxygen will recompute and show it on new
            // user input.
            search_results_window.hide();
            main_nav.removeClass('stickyHeader');
            menu_is_sticky = false;
        }
    };
    stick();  // on page refresh draw the menu on a right position
    $(window).on("scroll", stick);
}
function telegram_channel_language() {
  if (/^ru/.test(navigator.language)) {
    const channel = $('#telegram_channel');
    if (channel) {
      channel.attr('href', 'https://t.me/+AdadhDPVG5xhNWRi');
    }
  }
}
$(function() {
    if (setup_if_landing()) return;
    draw_toc();
    highlight_code();
    setup_page_edit();
    telegram_channel_language();
    sticky_menu();
});
</script>
</body>
</html>
